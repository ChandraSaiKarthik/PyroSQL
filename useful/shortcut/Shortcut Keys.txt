Ctrl+3:
/* Count Object */ SELECT COUNT(1) FROM 

----------------------------------------------------------------------------------------------

Ctrl+4:
/* SELECT TOP 100 */ SELECT TOP 100 * 

----------------------------------------------------------------------------------------------

Ctrl+5:
/* Select all */ SELECT * FROM 

----------------------------------------------------------------------------------------------

Ctrl+6:
/* Row Info */ SELECT  tb.object_id AS ObjectID, sc.name AS SchemaName, tb.name AS TableName, tb.max_column_id_used AS NumberOfColumns, pa.rows AS NumberOfRows FROM   sys.tables tb INNER JOIN   sys.schemas sc ON sc.schema_id = tb.schema_id INNER JOIN   sys.partitions pa ON tb.object_id = pa.object_id INNER JOIN   sys.indexes ix ON pa.object_id = ix.object_id AND pa.index_id = ix.index_id AND ix.index_id < 2 GROUP BY tb.object_id, tb.name, sc.name, tb.max_column_id_used, pa.rows ORDER BY sc.name, tb.name

----------------------------------------------------------------------------------------------

Ctrl+7:
/* Database Info */ EXEC (' IF CAST(CAST(SERVERPROPERTY(''ProductVersion'') as CHAR(2)) as NUMERIC) < 10 BEGIN SELECT @@VERSION RAISERROR (''To run this script SQL Server has to be Version 2008 or higher.'',16,1) END ');  EXEC(' IF(SERVERPROPERTY(''collation'')!=DATABASEPROPERTYEX(DB_name(),''collation'')) BEGIN USE tempdb; RAISERROR (''Because of database collation is not equal to the master context has been switched to tempdb.'',16,1) END ');  EXEC(' IF OBJECT_ID(''tempdb..##tbl_DB_Statistics'') IS NOT NULL DROP TABLE ##tbl_DB_Statistics; ');  EXEC(' IF OBJECT_ID(''tempdb..##tbl_VLFInfo'') IS NOT NULL DROP TABLE ##tbl_VLFInfo; ');  EXEC(' IF OBJECT_ID(''tempdb..##tbl_VLFCountResults'') IS NOT NULL DROP TABLE ##tbl_VLFCountResults; ');  EXEC(' IF OBJECT_ID(''tempdb..##tbl_AG_DBs'') IS NOT NULL DROP TABLE ##tbl_AG_DBs; ');  EXEC(' IF OBJECT_ID(''tempdb..##USP_GETDB'') IS NOT NULL DROP PROCEDURE ##USP_GETDB; ');  EXEC(' IF OBJECT_ID(''tempdb..##tbl_DB_CPU%'') IS NOT NULL DROP TABLE [##tbl_DB_CPU%]; ');  EXEC(' CREATE TABLE ##tbl_DB_Statistics( database_id INT, [File Id] INT, SizeMB VARCHAR(16), MaxSizeMB VARCHAR(16), UsedSpaceMB VARCHAR(16), FreeSpacePrc CHAR(6), [File Group] VARCHAR(128), UsedSpace FLOAT ); ');  EXEC(' CREATE TABLE ##tbl_VLFInfo ( RecoveryUnitID INT, FileID INT, FileSize BIGINT, StartOffset BIGINT, FSeqNo BIGINT, [Status] BIGINT, Parity BIGINT, CreateLSN NUMERIC(38)); ');  EXEC(' CREATE TABLE ##tbl_AG_DBs ( [DB_Name] SYSNAME NULL, database_id INT, [AG Name] SYSNAME, [Role] NVARCHAR(60), Node NVARCHAR(256), Position VARCHAR(5), is_local BIT, [Status] NVARCHAR(60), operational_Status TINYINT, [State] NVARCHAR(60), [Join State] NVARCHAR(60), [Recovery Status] NVARCHAR(60), recovery_health TINYINT, [Replica Sync Health] NVARCHAR(60), synchronization_health TINYINT, [Group Sync Health] NVARCHAR(60), [Group Health] NVARCHAR(60), [Last Error] NVARCHAR(1024), [Last Error #] VARCHAR(10), [Last Error DT] CHAR(23), sync_state NVARCHAR(60), synchronization_state TINYINT, [Commit participant] VARCHAR(3), [DB State] NVARCHAR(60), Suspended VARCHAR(3), [Suspend Reason] NVARCHAR(60), replica_server_name NVARCHAR(256), [Replica Owner] NVARCHAR(128), availability_mode_desc NVARCHAR(60), failover_mode_desc NVARCHAR(60), session_timeout INT, [Is Readable] NVARCHAR(60), create_date  CHAR(23), modify_date  CHAR(23), [backup_priority] INT, [endpoint_url] NVARCHAR(256), read_only_routing_url NVARCHAR(256), [Listener DNS Name] NVARCHAR(63), [Listener Port] INT, ip_configuration_string_from_cluster NVARCHAR(4000), [Current Listener State] NVARCHAR(max), recovery_lsn NUMERIC(25, 0), truncation_lsn NUMERIC(25, 0), last_sent_lsn NUMERIC(25, 0), last_sent_time DATETIME, last_received_lsn NUMERIC(25, 0), last_received_time DATETIME, last_hardened_lsn NUMERIC(25, 0), last_hardened_time DATETIME, last_redone_lsn NUMERIC(25, 0), last_redone_time DATETIME, log_send_queue_size BIGINT, log_send_rate BIGINT, redo_queue_size BIGINT, redo_rate BIGINT, filestream_send_rate BIGINT, end_of_log_lsn NUMERIC(25, 0), last_commit_lsn NUMERIC(25, 0)); ');  EXEC(' CREATE TABLE ##tbl_VLFCountResults([DB_id] INT, VLFCount INT); ');  EXEC(' CREATE TABLE [##tbl_DB_CPU%](DatabaseID INT,[CPU Percent] CHAR(8)); ');  EXEC(' CREATE PROCEDURE ##USP_GETDB @Param SYSNAME = NULL WITH RECOMPILE AS SET NOCOUNT ON  DECLARE @S CHAR(80), @V INT; DECLARE @SQL NVARCHAR(MAX), @SQL1 NVARCHAR(MAX), @SQL2 NVARCHAR(MAX); DECLARE @ag_present INT, @nl NVARCHAR(MAX), @or NCHAR(18), @ny NCHAR(36), @oo NCHAR(36); DECLARE @P NCHAR(1), @CompLevel INT, @DBid INT;  SELECT @V=CAST(CAST(SERVERPROPERTY(''ProductVersion'') as CHAR(2)) as NUMERIC)  , @S=REPLICATE(''-'',80), @ag_present = 0, @nl = '' with (NOLOCK) ''  , @CompLevel=compatibility_level, @P  = NULL  , @or=''OPTION (RECOMPILE)''  , @ny='' WHEN 0 THEN ''''NO'''' ELSE ''''YES'''' END''  , @oo='' WHEN 0 THEN ''''OFF'''' ELSE ''''ON'''' END''  , @DBid=CASE WHEN @Param is Null THEN 0   WHEN DB_ID(@Param) Is Null THEN -1 ELSE DB_ID(@Param) END FROM sys.databases WHERE database_id = 1;  PRINT @S; IF LEN(@Param)=1 and @DBid=-1 BEGIN  SELECT @P = UPPER(LEFT(@Param,1)), @Param = Null; END  /* Collect Availability Groups information */ IF @V >= 11 BEGIN  SET @SQL = '' INSERT INTO ##tbl_AG_DBs SELECT DB_NAME(database_id) , s.database_id , g.name , IsNull(st.role_desc, CASE WHEN r.replica_server_name = gs.primary_replica THEN ''''PRIMARY'''' ELSE ''''SECONDARY'''' END) , n.node_name , CASE s.is_local WHEN 1 THEN ''''LOCAL'''' ELSE '''''''' END , s.is_local , IsNull(st.operational_state_desc, '''''''') , st.operational_state , IsNull(st.connected_state_desc,'''''''') , IsNull(cs.join_state_desc,'''''''') , IsNull(st.recovery_health_desc,'''''''') , IsNull(st.recovery_health,'''''''') , IsNull(st.synchronization_health_desc,'''''''') , st.synchronization_health , gs.synchronization_health_desc , ISNull(gs.primary_recovery_health_desc, gs.secondary_recovery_health_desc) , IsNull(st.last_connect_error_description,'''''''') , IsNull(CAST(st.last_connect_error_number as VARCHAR),'''''''') , IsNull(CONVERT(VARCHAR(23),st.last_connect_error_timestamp,121),'''''''') , IsNull(s.synchronization_state_desc,'''''''') , s.synchronization_state , CASE s.is_commit_participant''+@ny+'' , IsNull(s.database_state_desc,'''''''') , CASE s.is_suspended''+@ny+'' , IsNull(s.suspend_reason_desc,'''''''') , IsNull(r.replica_server_name,'''''''') , [Replica Owner] = IsNull(suser_sname(r.owner_sid),'''''''') , r.availability_mode_desc , r.failover_mode_desc , r.session_timeout , CASE st.role WHEN 1  THEN r.primary_role_allow_connections_desc  ELSE r.secondary_role_allow_connections_desc END , IsNull(CONVERT(VARCHAR(23),r.create_date,121),'''''''') , IsNull(CONVERT(VARCHAR(23),r.modify_date,121),'''''''') , r.backup_priority , r.endpoint_url , IsNull(r.read_only_routing_url,'''''''') , l.dns_name , l.port , l.ip_configuration_string_from_cluster , agip.agip , s.recovery_lsn, s.truncation_lsn, s.last_sent_lsn, s.last_sent_time, s.last_received_lsn , s.last_received_time, s.last_hardened_lsn, s.last_hardened_time, s.last_redone_lsn , s.last_redone_time, s.log_send_queue_size, s.log_send_rate, s.redo_queue_size, s.redo_rate , s.filestream_send_rate, s.end_of_log_lsn, s.last_commit_lsn FROM sys.availability_groups as g''+@nl+'' INNER HASH JOIN sys.availability_replicas as r''+@nl+''  ON g.group_id = r.group_id LEFT JOIN sys.dm_hadr_database_replica_states as s''+@nl+''  ON s.group_id = g.group_id and s.replica_id = r.replica_id LEFT JOIN sys.dm_hadr_availability_replica_cluster_nodes as n''+@nl+''  ON r.replica_server_name = n.replica_server_name and g.name = n.group_name LEFT JOIN sys.dm_hadr_availability_replica_states as st''+@nl+''  ON s.replica_id = st.replica_id and s.group_id = st.group_id LEFT JOIN sys.dm_hadr_availability_replica_cluster_states as cs''+@nl+''  ON s.group_id = cs.group_id and cs.replica_id = s.replica_id LEFT JOIN sys.availability_group_listeners as l''+@nl+''  ON l.group_id = g.group_id CROSS APPLY (  SELECT TOP 100 PERCENT state_desc + '''': '''' + ip_address + '''';''''   + ip_subnet_mask + ''''/'''' + CAST(network_subnet_prefix_length as VARCHAR)   + CAST(CASE is_dhcp WHEN 1 THEN '''';DHCP'''' ELSE '''''''' END + '''';'''' as VARCHAR(5))  FROM sys.availability_group_listener_ip_addresses as ip''+@nl+''  WHERE l.listener_id = ip.listener_id  ORDER BY listener_id, state DESC  FOR XML PATH('''''''') ) as agip(agip) LEFT JOIN sys.dm_hadr_availability_group_states as gs''+@nl+''  ON gs.group_id = g.group_id WHERE '' + CAST(@DBid as VARCHAR) + '' < 1 OR s.database_id = '' + CAST(@DBid as VARCHAR) + '' /* Uncomment if you have Administrators permissions OPTION (QUERYTRACEON 9481, RECOMPILE) */ ;'';  PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   IF EXISTS ( SELECT TOP 1 1 FROM ##tbl_AG_DBs) SET @ag_present = 1; END  IF LEN(@Param) > 1 and @ag_present = 1 and @DBid = -1 and @V >= 11 IF EXISTS (SELECT TOP 1 1 FROM sys.availability_groups WHERE name = @Param) BEGIN  /* Return info for individual AG*/  SET @SQL = ''SELECT [AG Name], replica_server_name, [Replica Owner], [DB_Name] , Position, is_local, [Status], [State], [Join State] , availability_mode_desc, failover_mode_desc , session_timeout, [Is Readable], create_date, modify_date, backup_priority , [Recovery Status], [Replica Sync Health] , [Last Error #], [Last Error DT], [Commit participant] , [DB State], Suspended, [Suspend Reason] , endpoint_url, read_only_routing_url , recovery_lsn, truncation_lsn, last_sent_lsn, last_sent_time , last_received_lsn, last_received_time, last_hardened_lsn, last_hardened_time , last_redone_lsn, last_redone_time, log_send_queue_size, log_send_rate , redo_queue_size, redo_rate, filestream_send_rate, end_of_log_lsn, last_commit_lsn FROM ##tbl_AG_DBs WHERE [AG Name] = ''''''+@Param+'''''' ORDER BY replica_server_name, [DB_Name] ''+@or;  PRINT @SQL;  PRINT @S;  EXEC (@SQL);  RETURN; END  DECLARE @i INT = ( SELECT CASE WHEN @DBid > 0 THEN @DBid ELSE (  SELECT Min(d.database_id) FROM sys.databases as d  LEFT JOIN master.sys.database_recovery_status as s   ON d.database_id = s.database_id  WHERE @P is Null   OR @P IN (''N'',''D'',''S'',''U'',''W'')   OR (@P = ''F'' and d.recovery_model = 1)   OR (@P = ''B'' and d.recovery_model = 2)   OR (@P = ''L'' and d.recovery_model = 3)   OR (@P = ''O'' and d.[state] != 0)   OR (@P = ''C'' and d.[compatibility_level] != @CompLevel)   OR (@P = ''M'' and d.user_access != 0)   OR (@P = ''R'' and d.is_read_only != 0)   OR (@P = ''E'' and d.recovery_model = 1 and s.last_log_backup_lsn is Null) ) END );  WHILE @i Is not Null IF @DBid<=0 OR @i=@DBid BEGIN  SELECT @SQL2 = '' INSERT INTO ##tbl_DB_Statistics (database_id, [File Id], SizeMB, UsedSpaceMB, FreeSpacePrc, UsedSpace) SELECT  Database_Id=DB_ID('''''' + DB_NAME(@i) + ''''''),  [File Id]=Null,  SizeMB=Null,  UsedSpaceMB=''''UNKNOWN'''',  FreeSpacePrc=''''0'''',0  ''+@or+'';'';   SELECT @SQL = CASE [state] + user_access WHEN 0  THEN ''USE ['' + DB_NAME(@i) + '']; WITH DbData as ( SELECT Database_Id=DB_ID('''''' + DB_NAME(@i) + '''''')  ,[File Id]=f.file_id  ,[Physical Name]=f.physical_name  ,SizeMB=CAST(CAST(ROUND(f.Size/128.,3) as DECIMAL(16,3)) as VARCHAR(16))  ,MaxSizeMB=CASE f.max_size WHEN 0 THEN ''''NO GROWTH'''' WHEN -1 THEN ''''2097152.000'''' ELSE CAST(CAST(ROUND(f.max_size/128.,3) as DECIMAL(16,3)) as VARCHAR(16)) END  ,UsedSpaceMB=CAST(CAST(ROUND(FILEPROPERTY(f.name, ''''SpaceUsed'''')/128.,3) as DECIMAL(16,3)) as VARCHAR(16))  ,FreeSpacePrc=RIGHT(''''  '''' + CAST(CAST((1 - FILEPROPERTY(f.name, ''''SpaceUsed'''') * 1./ f.size) * 100 as DECIMAL(5,2)) as VARCHAR(6)),6)  ,[File Group]=CASE f.file_id WHEN 2 THEN ''''Log File'''' ELSE IsNull(g.name,''''N/A'''') END  ,UsedSpace=FILEPROPERTY(f.name, ''''SpaceUsed'''') * 1./ f.size FROM sys.database_files as f''+@nl+'' LEFT JOIN sys.filegroups as g''+@nl+''ON f.data_space_id = g.data_space_id ) INSERT INTO ##tbl_DB_Statistics SELECT Database_Id, [File Id]  ,SizeMB=RIGHT(SPACE(16) + CASE WHEN Len(SizeMB) > 7   THEN CASE WHEN Len(SizeMB) > 10   THEN LEFT(SizeMB, LEN(SizeMB) - 10) + '''','''' + SUBSTRING(SizeMB, LEN(SizeMB) - 10, 3) + '''','''' + RIGHT(SizeMB, 7)   ELSE LEFT(SizeMB, LEN(SizeMB) - 7) + '''','''' + RIGHT(SizeMB, 7) END ELSE SizeMB END, 16)  ,MaxSizeMB=RIGHT(SPACE(16) + CASE WHEN Len(MaxSizeMB) > 7   THEN CASE WHEN Len(MaxSizeMB) > 10   THEN LEFT(MaxSizeMB, LEN(MaxSizeMB) - 10) + '''','''' + SUBSTRING(MaxSizeMB, LEN(MaxSizeMB) - 10, 3) + '''','''' + RIGHT(MaxSizeMB, 7)   ELSE LEFT(MaxSizeMB, LEN(MaxSizeMB) - 7) + '''','''' + RIGHT(MaxSizeMB, 7) END ELSE MaxSizeMB END, 16)  ,UsedSpaceMB=RIGHT(SPACE(16) + CASE WHEN Len(UsedSpaceMB) > 7   THEN CASE WHEN Len(UsedSpaceMB) > 10   THEN LEFT(UsedSpaceMB, LEN(UsedSpaceMB) - 10) + '''','''' + SUBSTRING(UsedSpaceMB, LEN(UsedSpaceMB) - 10, 3) + '''','''' + RIGHT(UsedSpaceMB, 7)   ELSE LEFT(UsedSpaceMB, LEN(UsedSpaceMB) - 7) + '''','''' + RIGHT(UsedSpaceMB, 7) END ELSE UsedSpaceMB END, 16)   ,FreeSpacePrc   ,[File Group]   ,UsedSpace FROM DbData ''+@or  ELSE   @SQL2  END  FROM sys.databases with (nolock)  WHERE database_id = @i;   SELECT @SQL1 = CASE [state] + user_access WHEN 0  THEN ''USE ['' + DB_NAME(@i) + '']; INSERT INTO ##tbl_VLFInfo('' + CASE WHEN @V < 11 THEN '''' ELSE ''RecoveryUnitID, '' END + ''FileID, FileSize, StartOffset, FSeqNo, [Status], Parity, CreateLSN) EXEC sp_executesql N''''DBCC LOGINFO() WITH NO_INFOMSGS'''';      INSERT INTO ##tbl_VLFCountResults SELECT DB_ID(), COUNT(*) FROM ##tbl_VLFInfo;  TRUNCATE TABLE ##tbl_VLFInfo;''  ELSE '''' END FROM sys.databases with (nolock) WHERE database_id = @i;    PRINT @SQL  PRINT @SQL1  RAISERROR (@S,10,1) WITH NOWAIT    BEGIN TRY   EXEC (@SQL);  END TRY  BEGIN CATCH      RAISERROR (@S,10,1) WITH NOWAIT   PRINT ''Error in script execution. Executing different script:''   RAISERROR (@S,10,1) WITH NOWAIT   PRINT @SQL2   RAISERROR (@S,10,1) WITH NOWAIT   EXEC (@SQL2);  END CATCH   BEGIN TRY   EXEC (@SQL1);  END TRY  BEGIN CATCH   PRINT ''Error accessing DBCC LOGINFO().''  END CATCH   SELECT @i = Min(d.database_id)  FROM sys.databases as d with (nolock)   LEFT JOIN master.sys.database_recovery_status as s with (nolock)    ON d.database_id = s.database_id   WHERE d.database_id > @i AND (    @P is Null    OR @P IN (''N'',''D'',''S'',''U'',''W'')    OR (@P = ''F'' and d.recovery_model = 1)    OR (@P = ''B'' and d.recovery_model = 2)    OR (@P = ''L'' and d.recovery_model = 3)    OR (@P = ''O'' and d.[state] != 0)    OR (@P = ''C'' and d.[compatibility_level] != @CompLevel)    OR (@P = ''M'' and d.user_access != 0)    OR (@P = ''E'' and d.recovery_model = 1 and s.last_log_backup_lsn is Null)   ) END ELSE /* IF doing single DB we do a skip */ BEGIN  SELECT @i = Min(database_id)  FROM sys.databases with (nolock)  WHERE database_id > @i; END  SET @SQL=''INSERT INTO [##tbl_DB_CPU%] SELECT DatabaseID, CAST(CAST(SUM(total_worker_time)*100./(SELECT SUM(total_worker_time) FROM sys.dm_exec_query_stats with (NOLOCK) ) as DECIMAL(5,2)) as VARCHAR)+'''' %'''' FROM sys.dm_exec_query_stats AS qs with (NOLOCK) CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] FROM sys.dm_exec_plan_attributes(qs.plan_handle) WHERE attribute = N''''dbid'''') AS F_DB GROUP BY DatabaseID HAVING SUM(total_worker_time) > (SELECT SUM(total_worker_time) FROM sys.dm_exec_query_stats with (NOLOCK) ) / 100'' +@or  PRINT SUBSTRING(@SQL,1,4000) PRINT SUBSTRING(@SQL,4001,8000) RAISERROR (@S,10,1) WITH NOWAIT EXEC (@SQL);   SET @SQL='';WITH Counters as (  SELECT d.database_id, c.cntr_value, c.counter_name  , File_Id = CASE WHEN RTRIM(c.counter_name) in (  ''''Log Bytes Flushed/sec'''',''''Log Flush Wait Time'''',  ''''Log Flush Waits/sec'''',''''Log Flush Write Time (ms)'''',  ''''Log Flushes/sec'''',''''Log Pool Cache Misses/sec'''',  ''''Log Pool Disk Reads/sec'''',''''Log Pool Requests/sec'''',  ''''Log Truncations'''') THEN 2 ELSE 1 END  FROM sys.dm_os_performance_counters as c''+@nl+''  INNER JOIN sys.databases as d''+@nl+''ON name = RTRIM(instance_name)  WHERE RTRIM(SUBSTRING(object_name, PATINDEX(''''%:%'''', object_name)+1, 99))   not in (''''Availability Replica'''',''''Broker Activation'''',''''HTTP Storage''''   ,''''Locks'''',''''SQL Errors'''',''''Broker Activation'''',''''Cursor Manager by Type''''   ,''''Database Mirroring'''',''''Plan Cache'''') ), Perf_Counters as ( SELECT * FROM Counters pivot (SUM (cntr_value) for counter_name in ( [Cache Hit Ratio Base],[Cache Hit Ratio],[Active Transactions], [Log Bytes Flushed/sec],[Log Flush Wait Time],[Log Flush Waits/sec], [Log Flush Write Time (ms)],[Log Flushes/sec],[Log Pool Cache Misses/sec], [Log Pool Disk Reads/sec],[Log Pool Requests/sec],[Log Truncations], [Backup/Restore Throughput/sec],[Bulk Copy Rows/sec],[Bulk Copy Throughput/sec], [Cache Entries Count],[Cache Entries Pinned Count],[DBCC Logical Scan Bytes/sec], ''+CASE @ag_present WHEN 0 THEN '''' ELSE ''[Mirrored Write Transactions/sec],[Log Bytes Received/sec],[Redone Bytes/sec], [Transaction Delay],'' END+''[Transactions/sec],[Write Transactions/sec] )) as AvgIncomePerDay) SELECT [Database ID]=t.database_id ,[Database State]=d.state_desc ,[Database Name]=d.name ,t.[File Group] ,[File Id]=mf.[file_id] ,[File Name]=mf.name ,[Physical Name]=mf.physical_name ,[File Type]=mf.type_desc ,[VLF Count]=IsNull(CASE WHEN mf.type_desc = ''''LOG'''' THEN CAST(v.VLFCount as VARCHAR)   WHEN t.database_id = 2 THEN ''''Org.Size: '''' + CAST(mf.size/128 as VARCHAR) + ''''Mb''''  ELSE '''''''' END,-1) ,[File Size, MB]=IsNull(t.SizeMB, CASE WHEN mf.size/128. > = 1000000 THEN CAST(mf.size/128000000 as VARCHAR) + '''','''' ELSE '''''''' END + RIGHT(CASE WHEN mf.size >= 128000000 THEN ''''000'''' ELSE '''''''' END + CASE WHEN mf.size/128. > = 1000 THEN CAST(((mf.size/128) % 1000000) / 1000 as VARCHAR) + '''','''' ELSE '''''''' END ,4) + RIGHT(CASE WHEN mf.size >= 128000 THEN ''''000'''' ELSE '''''''' END + CASE WHEN mf.size/128. > 0 THEN CAST(((mf.size/128) % 1000) as VARCHAR) END,3) + ''''.'''' + SUBSTRING(CAST( ROUND(mf.size/128. - mf.size/128,1) as VARCHAR),3,1)) ,[Used Space, MB]=IsNull(t.UsedSpaceMB,''''N/A'''') ,[Free Space]=IsNull(t.FreeSpacePrc + '''' %'''',''''N/A'''') ,AutoGrowth=CASE is_percent_growth WHEN 0 THEN CAST(growth/128 as VARCHAR) + '''' Mb''''   ELSE CAST(growth as VARCHAR) + '''' %'''' END ,[Max File Size, MB]=t.MaxSizeMB ,[Avg Read Wait, ms]=CAST(ROUND(( s.io_stall_read_ms / ( 1.0 + s.num_of_reads ) ),3) as FLOAT) ,[Avg Write Wait, ms]=CAST(ROUND(( s.io_stall_write_ms / ( 1.0 + s.num_of_writes ) ),3) as FLOAT) ,[CPU Percent]=IsNull(dbs.[CPU Percent],'''''''') ,[Created]=CONVERT(CHAR(19),d.create_date,121) ,[File State]=mf.state_desc ,[Log Reuse Wait]=d.log_reuse_wait_desc ,[User Access]=d.user_access_desc ,[Recovery Model]=d.recovery_model_desc ,[Last Full Backup]=CASE d.database_id WHEN 2 THEN ''''N/A'''' ELSE CASE WHEN lbu.Last_BU is Null THEN ''+ CASE @ag_present WHEN 0 THEN ''''''Unknown'''''' ELSE '' CASE a.role WHEN ''''Secondary'''' THEN ''''Secondary AG'''' ELSE ''''Unknown'''' END'' END + '' ELSE lbu.Last_BU END END ,[Backup Chain]=CASE d.recovery_model WHEN 1 THEN  CASE WHEN r.last_log_backup_lsn is Null THEN ''''Broken'''' ELSE ''''Good'''' END ELSE ''''N/A'''' END ,[Compatibility Level]=[compatibility_level] ,[Auto Create Stats]=CASE d.is_auto_create_stats_on''+@ny+'' ,[Auto Update Stats]=CASE d.is_auto_update_stats_on''+@ny+'' ,[Auto Close]=CASE d.is_auto_close_on''+@ny+'' ,[Auto Shrink]=CASE d.is_auto_shrink_on''+@ny+'' ,[Snapshot Isolation]=d.snapshot_isolation_state_desc ,[Collation Name]=d.collation_name ,[Page Verify Option]=d.page_verify_option_desc ,[Access State]=CASE d.is_read_only WHEN 0 THEN ''''READ_WRITE'''' ELSE ''''READ_ONLY'''' END , CASE d.is_in_standby WHEN 0 THEN ''''Active'''' ELSE ''''Standby for Log Restore'''' END as [Mode] ''+ CASE @ag_present WHEN 0 THEN '''' ELSE '' ,[Availability Group]=IsNull(a.[AG Name],''''N/A'''') ,[AG Synchronization Health]=IsNull(a.[Sync Health],''''N/A'''') ,[AG Synchronization State]=IsNull(a.sync_state,''''N/A'''') ,[AG State]=IsNull(a.[DB State],''''N/A'''') ,[Role]=IsNull(a.Role,''''N/A'''') ,[Is Readable]=IsNull(a.[Is Readable],''''N/A'''') '' END+ '',pc.* FROM ##tbl_DB_Statistics as t INNER JOIN master.sys.databases as d''+@nl+''  ON t.database_id = d.database_id '' +  CASE @ag_present WHEN 0 THEN '''' ELSE '' LEFT JOIN ( SELECT DISTINCT a.database_id, a.[AG Name] , [Health] = (SELECT CASE MIN(synchronization_health)  WHEN 0 THEN ''''NOT HEALTHY'''' WHEN 1 THEN ''''PARTIALLY HEALTHY''''  WHEN 2 THEN ''''HEALTHY'''' END FROM ##tbl_AG_DBs as i  WHERE i.database_id = a.database_id GROUP BY i.database_id) , [Sync Health] = ( /*Logic to retranslate 3->(-2), 4->(-1)*/  SELECT CASE MIN(synchronization_state-(synchronization_state/3)*5)  WHEN 0 THEN ''''NOT SYNCHRONIZING'''' WHEN 1 THEN ''''SYNCHRONIZING''''  WHEN 2 THEN ''''SYNCHRONIZED'''' WHEN -1 THEN ''''INITIALIZING''''  WHEN -2 THEN ''''REVERTING'''' END FROM ##tbl_AG_DBs as i  WHERE i.database_id = a.database_id GROUP BY i.database_id) , [DB State] , [Role] , [Is Readable] , sync_state FROM ##tbl_AG_DBs as a WHERE is_local = 1) as a  ON t.database_id = a.database_id'' END + '' LEFT JOIN sys.master_files AS mf''+@nl+''  ON d.database_id = mf.database_id AND (t.[File Id] = mf.[file_id] or t.[File Id] is Null) LEFT JOIN (  SELECT database_name, Last_BU=CONVERT(CHAR(19),MAX(backup_finish_date),121)  FROM msdb.dbo.backupset''+@nl+'' WHERE type = ''''D'''' GROUP BY database_name ) as lbu ON d.name = lbu.database_name LEFT JOIN master.sys.database_recovery_status as r ''+@nl+''ON r.database_id = d.database_id LEFT JOIN Perf_Counters as pc ON pc.database_id = d.database_id and pc.[file_id] = mf.[file_id] LEFT JOIN sys.dm_io_virtual_file_stats(NULL, NULL) as s  ON t.database_id = s.database_id and mf.[file_id] = s.[file_id] LEFT JOIN ##tbl_VLFCountResults as v ON v.[DB_id] = d.database_id LEFT JOIN [##tbl_DB_CPU%] as dbs ON dbs.DatabaseID = d.database_id '';  SET @SQL += '' ORDER BY '' + CASE @P   WHEN ''N'' THEN ''d.name''   WHEN ''D'' THEN ''d.create_date''   WHEN ''S'' THEN ''mf.size DESC''   WHEN ''U'' THEN ''t.UsedSpace DESC''   WHEN ''W'' THEN ''s.io_stall_read_ms / ( 1.0 + s.num_of_reads ) + s.io_stall_write_ms / ( 1.0 + s.num_of_writes ) DESC''   ELSE ''d.Database_id''  END   SET @SQL += '' ''+@or+'';'';   PRINT SUBSTRING(@SQL,1,4000)  PRINT SUBSTRING(@SQL,4001,8000)  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);  SET @SQL = ''SELECT [Mount Point]=vs.volume_mount_point ,[Avg Read Wait, ms]=CAST(ROUND(( SUM(s.io_stall_read_ms) / ( 1.0 + SUM(s.num_of_reads) ) ),3) as FLOAT) ,[Avg Write Wait, ms]=CAST(ROUND(( SUM(s.io_stall_write_ms) / ( 1.0 + SUM(s.num_of_writes) ) ),3) as FLOAT) ,[Total Volume Size (GB)]=CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) ,[Available Volume Size (GB)]=CONVERT(DECIMAL(18,2),vs.available_bytes/1073741824.0) ,[Volume Space Free %]=CAST(CAST(vs.available_bytes AS FLOAT)/ CAST(vs.total_bytes AS FLOAT) AS DECIMAL(18,2)) * 100 ,vs.file_system_type,vs.logical_volume_name FROM sys.dm_io_virtual_file_stats(NULL, NULL) as s CROSS APPLY sys.dm_os_volume_stats(s.database_id, s.[file_id]) AS vs GROUP BY vs.volume_mount_point, vs.file_system_type, vs.logical_volume_name, vs.total_bytes, vs.available_bytes ''+@or+'';'';   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);  IF @ag_present > 0 BEGIN  SET @SQL = ''SELECT [AG Name] ,Replicas=COUNT(DISTINCT replica_server_name) ,Databases=COUNT(DISTINCT database_id) ,[Group Health], [Group Sync Health] ,[Listener DNS Name], [Listener Port], ip_configuration_string_from_cluster ,[Current Listener State] FROM ##tbl_AG_DBs GROUP BY [AG Name], [Group Health], [Group Sync Health] , [Listener DNS Name], [Listener Port], ip_configuration_string_from_cluster , [Current Listener State] ORDER BY [AG Name] ''+@or+'';'';  PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL); END  IF @DBid = 0 BEGIN  /* Extract List of SQL Server Logins */  SET @SQL = ''SELECT [Login/User Name]=IsNull(l.name,pr.Name) ,[Login/User Type]=pr.type_desc ,pr.default_database_name ,[Assigned Roles]=IsNull(SUBSTRING((  SELECT '''', '''' + p.name  FROM master.sys.server_role_members as rm  INNER JOIN master.sys.server_principals as p   ON rm.role_principal_id = p.principal_id and p.type = ''''R''''  WHERE rm.member_principal_id = pr.principal_id  FOR XML PATH('''''''') ),3,8000),''''NO ROLE ASSIGNED'''') ,[Special Permissions]=IsNull(SUBSTRING((  SELECT '''', '''' + permission_name + ''''('''' + ip.name + '''')''''  FROM master.sys.server_permissions as sp  INNER JOIN master.sys.server_principals as ip ON ip.principal_id = sp.grantor_principal_id  WHERE sp.grantee_principal_id = pr.principal_id  FOR XML PATH('''''''') ),3,8000),''''N/A'''') ,is_disabled=IsNull(CAST(pr.is_disabled as varchar),''''N/A'''') ,is_policy_checked=IsNull(CAST(l.is_policy_checked as varchar),''''N/A'''') ,is_expiration_checked=IsNull(CAST(l.is_expiration_checked as varchar),''''N/A'''') ,[Password Problem]=CASE  WHEN PWDCOMPARE(l.name,l.password_hash) = 1 THEN ''''Login With Password Same AS Name''''  WHEN PWDCOMPARE('''''''',l.password_hash) = 1 THEN ''''Login With Empty Password''''  ELSE ''''No Problem Found'''' END FROM master.sys.sql_logins as l RIGHT JOIN master.sys.server_principals as pr ON l.principal_id = pr.principal_id WHERE pr.type in (''''S'''',''''U'''',''''G'''') ''+@or+'';''   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL); END  IF @DBid > 0 BEGIN  /* Extract List of Partition Schemas if any */  SET @SQL='' USE [''+@Param+'']; IF EXISTS (SELECT TOP 1 1 FROM sys.partition_schemes''+@nl+'') SELECT ps.name as Partition_Schema, pf.name as Partition_Function , pf.modify_date as Last_Modified , CASE pf.boundary_value_on_right WHEN 0 THEN ''''LEFT'''' ELSE ''''RIGHT'''' END as Function_Type , R1.value as Min_Border_Value, R2.value as Max_Border_Value , ds.destination_id as Partition_Order , FG.name as [FileGroup_Name] ,total_pages=SUM(IsNull(AU.total_pages,0)) ,used_pages=SUM(IsNull(AU.used_pages,0)) ,data_pages=SUM(IsNull(AU.data_pages,0)) ,[File_Name]=sf.name ,Physical_File_Name=sf.filename FROM sys.partition_schemes as ps''+@nl+'' INNER JOIN sys.destination_data_spaces as ds''+@nl+''ON ps.data_space_id = ds.partition_scheme_id INNER JOIN sys.partition_functions as pf''+@nl+''ON pf.function_id = ps.function_id INNER JOIN sys.filegroups AS FG''+@nl+''ON FG.data_space_id = ds.data_space_id INNER JOIN sys.sysfiles AS sf''+@nl+''ON sf.groupid = ds.data_space_id LEFT JOIN sys.partition_range_values as R1''+@nl+''ON R1.function_id = pf.function_id and R1.boundary_id + 1 = ds.destination_id LEFT JOIN sys.partition_range_values as R2''+@nl+''ON R2.function_id = pf.function_id and R2.boundary_id = ds.destination_id LEFT JOIN sys.allocation_units AS AU''+@nl+''ON AU.data_space_id = ds.data_space_id GROUP BY  ps.name, pf.name, pf.modify_date, pf.boundary_value_on_right, R1.value, R2.value  , ds.destination_id, FG.name, sf.name, sf.filename ORDER BY ps.name, ds.destination_id ''+@or+'';'';   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   /* Extract individual database parameters */  SET @SQL = ''SELECT tt.DBProperty, tt.DBPropertyValue FROM sys.databases as t''+@nl+'' CROSS APPLY (VALUES (CAST(database_id as NVARCHAR), ''''Database Id'''') ,(name, ''''Datanase Name'''') ,(state_desc COLLATE SQL_Latin1_General_CP1_CI_AS, ''''DB State'''') ,(user_access_desc COLLATE SQL_Latin1_General_CP1_CI_AS, ''''User Access'''') ,(recovery_model_desc COLLATE SQL_Latin1_General_CP1_CI_AS, ''''DB recovery model'''') ,(collation_name COLLATE SQL_Latin1_General_CP1_CI_AS, ''''DB Collation'''') ,(log_reuse_wait_desc COLLATE SQL_Latin1_General_CP1_CI_AS, ''''Log Reuse'''') ,(page_verify_option_desc COLLATE SQL_Latin1_General_CP1_CI_AS, ''''PAGE_VERIFY'''') ,(CASE is_read_only''+@ny+'', ''''READ_ONLY'''') ,(CASE is_in_standby''+@ny+'', ''''DB IN Standby'''') ,(CASE is_cleanly_shutdown''+@ny+'', ''''DB Is cleanly shutdown'''') ,(CASE is_encrypted''+@ny+'', ''''DB_ENCRYPTED'''') ,(CASE is_auto_shrink_on''+@ny+'', ''''AUTO_SHRINK'''') ,(CASE is_ansi_null_default_on''+@oo+'', ''''ANSI_NULL_DEFAULT'''') ,(CASE is_ansi_nulls_on''+@oo+'', ''''ANSI_NULLS'''') ,(CASE is_ansi_warnings_on''+@oo+'', ''''ANSI_WARNINGS'''') ,(CASE is_ansi_padding_on''+@oo+'', ''''ANSI_PADDING'''') ,(CASE is_arithabort_on''+@oo+'', ''''Arithmetic Abort Enabled'''') ,(CASE is_quoted_identifier_on''+@oo+'', ''''QUOTED_IDENTIFIER'''') ,(CASE is_auto_create_stats_on''+@oo+'', ''''AUTO_CREATE_STATISTICS'''') ,(CASE is_auto_update_stats_on''+@oo+'', ''''AUTO_UPDATE_STATISTICS'''') ,(CASE is_auto_update_stats_async_on''+@oo+'', ''''AUTO_UPDATE_STATISTICS_ASYNC'''') ,(CASE is_read_committed_snapshot_on''+@oo+'', ''''READ_COMMITTED_SNAPSHOT'''') ,(CASE snapshot_isolation_state''+@ny+'', ''''ALLOW_SNAPSHOT_ISOLATION'''') ,(CASE is_concat_null_yields_null_on''+@oo+'', ''''CONCAT_NULL_YIELDS_NULL'''') ,(CASE is_recursive_triggers_on''+@oo+'', ''''RECURSIVE_TRIGGERS'''') ,(CASE is_parameterization_forced''+@ny+'', ''''FORCED_PARAMETRIZATION'''') ,(CASE is_db_chaining_on''+@oo+'', ''''DB_CHAINING'''') ,(CASE is_numeric_roundabort_on''+@oo+'', ''''NUMERIC_ROUNDABORT'''') ,(CASE is_trustworthy_on''+@oo+'', ''''TRUSTWORTHY'''') ,(CASE is_auto_close_on''+@oo+'', ''''AUTO_CLOSE'''') ,(CASE is_date_correlation_on''+@oo+'', ''''DATE_CORRELATION_OPTIMIZATION'''') ,(CASE is_cdc_enabled''+@ny+'', ''''CHANGE_DATA_CAPTURE Enabled'''') ,(CASE is_fulltext_enabled''+@ny+'', ''''FULL-TEXT Enabled'''') ,(CASE is_supplemental_logging_enabled''+@ny+'', ''''SUPPLEMENTAL_LOGGING Enabled'''') ,(CASE is_broker_enabled''+@ny+'', ''''DB_BROKER Enabled'''') ,(CASE is_honor_broker_priority_on''+@oo+'', ''''HONOR_BROKER_PRIORITY'''') ,(CASE is_local_cursor_default''+@ny+'', ''''CURSOR_DEFAULT'''') ,(CASE is_cursor_close_on_commit_on''+@oo+'', ''''CURSOR_CLOSE_ON_COMMIT'''') ,(CASE is_subscribed''+@ny+'', ''''REPLICATION_SUBSCRIPTION_DB'''') ,(CASE is_published''+@ny+'', ''''REPLICATION_PUBLICATION_DB'''') ,(CASE is_merge_published''+@ny+'', ''''MERGE_REPLICATION_PUBLICATION_DB'''') ,(CASE is_distributor''+@ny+'', ''''REPLICATION_DISTRIBUTION_DB'''') ,(CASE is_sync_with_backup''+@ny+'', ''''MARKED_FOR_REPLICATION_BACKUP_SYNC'''') ,(CASE is_master_key_encrypted_by_server''+@ny+'', ''''DB_ENCRYPTED_MASTER_KEY'''') ) tt (DBPropertyValue, DBProperty) WHERE name = ''''''+@Param+'''''' ''+@or+'';'';   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   /* Extract database Users */  SET @SQL = '' SELECT [User Name]=d.name ,[Login Name]=IsNull(p.name,''''N/A'''') ,d.type_desc ,[Assigned Roles]=IsNull(SUBSTRING((  SELECT '''', '''' + dr.name  FROM [''+@Param+''].sys.database_principals as dr  INNER JOIN [''+@Param+''].sys.database_role_members as m   ON dr.principal_id = m.role_principal_id  WHERE d.principal_id = m.member_principal_id  FOR XML PATH('''''''') ),3,8000),''''N/A''''),d.create_date,d.modify_date FROM [''+@Param+''].sys.database_principals as d LEFT JOIN master.sys.server_principals as p ON p.sid = d.sid WHERE d.is_fixed_role = 0 and d.principal_id > 4 ''+@or+'';'';   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   /* Extract database backup History */  SET @SQL = ''  ;WITH BU as (SELECT backup_start_date, backup_finish_date,  [Type]=CASE type   WHEN ''''L'''' THEN ''''LOG''''   WHEN ''''D'''' THEN ''''FULL''''   WHEN ''''I'''' THEN ''''DIFF''''   ELSE ''''N/A'''' END  ,BMb=CAST(CAST(ROUND(backup_size / 1048576.,3) as DECIMAL(16,3)) as VARCHAR(16))  ,CMb=CAST(CAST(ROUND(compressed_backup_size / 1048576.,3) as DECIMAL(16,3)) as VARCHAR(16))  ,[Backup File Full Name]=f.physical_device_name, backup_set_id  FROM msdb.dbo.backupset as s  LEFT JOIN msdb.dbo.backupmediafamily as f ON s.media_set_id = f.media_set_id  WHERE database_name = ''''''+@Param+''''''  )  SELECT backup_start_date, backup_finish_date, [Type], [Backup File Full Name]  ,BackupSizeMb=RIGHT(SPACE(16) + CASE WHEN Len(BMb) > 7   THEN CASE WHEN Len(BMb) > 10   THEN LEFT(BMb, LEN(BMb) - 10) + '''','''' + SUBSTRING(BMb, LEN(BMb) - 10, 3) + '''','''' + RIGHT(BMb, 7)     ELSE LEFT(BMb, LEN(BMb) - 7) + '''','''' + RIGHT(BMb, 7) END ELSE BMb END, 16)  ,CompressedMb=RIGHT(SPACE(16) + CASE WHEN Len(CMb) > 7   THEN CASE WHEN Len(CMb) > 10   THEN LEFT(CMb, LEN(CMb) - 10) + '''','''' + SUBSTRING(CMb, LEN(CMb) - 10, 3) + '''','''' + RIGHT(CMb, 7)     ELSE LEFT(CMb, LEN(CMb) - 7) + '''','''' + RIGHT(CMb, 7) END ELSE CMb END, 16)  FROM BU  ORDER BY backup_set_id DESC  ''+@or+'';'';   PRINT @SQL  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);  END  RETURN 0; ');  EXEC('  EXEC ##USP_GETDB ');  EXEC(' ');


-----------------------------------------------------------------------------------------------


Ctrl+8:
/* Table Info */ EXEC ('  IF OBJECT_ID(''tempdb..#USP_HELP'') IS NOT NULL  DROP PROCEDURE #USP_HELP;  ');  EXEC('  CREATE PROCEDURE #USP_HELP  @Object_Name SYSNAME = NULL,  @Parameter2 VARCHAR(8) = ''LIMITED''  WITH RECOMPILE  AS  SET NOCOUNT ON    PRINT ''Function Ctrl-0 Options: SQL Server Objects.'';  PRINT ''1. No options: Returns List of all tables and List all objects in current DB.'';  PRINT '' It is normal that tables with less records are bigger in size.'';  PRINT ''2. Object Name/ID: Object''''s code or full description.'';  PRINT ''3. Index/Table name (+ parameter): Gives info about index allocation. Second is reporting mode: SAMPLED or DETAILED.'';  PRINT ''For system tables requires fully specifired name like: ''''sys.objects''''.''  PRINT ''Does not handle: Synonyms, Defaults, Constraints.''  PRINT ''Example 1: tbl_MyTable '';  PRINT ''Example 2: ''''CLUIX_MyTable'''',''''DETAILED'''' '';    DECLARE @S CHAR(80);  DECLARE @SQL NVARCHAR(MAX);  DECLARE @Object_Id INT;  DECLARE @Index_Id INT = NULL;  DECLARE @Object_Type char(2) = NULL;  DECLARE @V INT; /* SQL Server Major Version */    SELECT @V= CAST(CAST(SERVERPROPERTY(''ProductVersion'') as CHAR(2)) as NUMERIC), @S = REPLICATE(''-'',80);  PRINT @S;    IF @Object_Name COLLATE database_default Is Null  BEGIN   SET @SQL = ''SELECT          DB_NAME() AS DatabaseName,          OBJECT_SCHEMA_NAME(OBJECT_ID) AS SchemaName,    OBJECT_NAME(OBJECT_ID) TableName,    SUM(CASE WHEN index_id < 2 THEN row_count ELSE 0 END) Row_Count,    ROUND(CAST(SUM(CASE WHEN index_id < 2 THEN reserved_page_count ELSE 0 END) AS float)/128.,3) as Data_Size_MB,    ROUND(CAST(SUM(CASE WHEN index_id < 2 THEN used_page_count ELSE 0 END) AS float)/128.,3) as Used_Data_Space_MB,        ROUND(CAST(SUM(CASE WHEN index_id > 1 THEN reserved_page_count ELSE 0 END) AS float)/128.,3) as Index_Size_MB,    ROUND(CAST(SUM(CASE WHEN index_id > 1 THEN used_page_count ELSE 0 END) AS float)/128.,3)as Used_Index_Space_MB,      ROUND(CAST(SUM(reserved_page_count) AS float)/128.,3) as Full_Size_MB,    ROUND(CAST(SUM(used_page_count) AS float)/128.,3) AS Full_Used_Space_MB   FROM sys.dm_db_partition_stats as st with (NOLOCK)   WHERE OBJECT_SCHEMA_NAME(OBJECT_ID) != ''''sys''''   GROUP BY OBJECT_SCHEMA_NAME(OBJECT_ID), OBJECT_NAME(OBJECT_ID)   ORDER BY OBJECT_SCHEMA_NAME(OBJECT_ID), OBJECT_NAME(OBJECT_ID)   OPTION (RECOMPILE);'';   PRINT @SQL;   PRINT @S;   EXEC (@SQL);        /*   SET @SQL = ''SELECT [Object_Name] = ''''['''' + SCHEMA_NAME(SCHEMA_ID) + ''''].['''' + [name] + '''']''''    , [Exec on SQL Startup] = CASE      WHEN [type] = ''''P'''' and OBJECTPROPERTY([object_id], ''''ExecIsStartUp'''') = 0 THEN ''''No''''     WHEN [type] = ''''P'''' and OBJECTPROPERTY([object_id], ''''ExecIsStartUp'''') = 1 THEN ''''Yes''''     ELSE ''''N/A'''' END    , [type], type_desc, create_date, modify_date, [object_id]    , [Parent Object] = ''''['''' + OBJECT_SCHEMA_NAME(parent_object_id) + ''''].['''' + OBJECT_NAME(parent_object_id) + '''']''''    , parent_object_id    FROM sys.objects with (NOLOCK)    WHERE [type] not in (''''IT'''', ''''SQ'''', ''''U'''')    ORDER BY [Parent Object], [type], [name]    OPTION (RECOMPILE);'';   PRINT @SQL;   PRINT @S;   EXEC (@SQL);      */  END  ELSE  BEGIN /* @Object_Name Is NOT Null */   IF IsNumeric(@Object_Name) = 1    SELECT TOP 1 @Object_Type = Type, @Object_Id = Object_Id    FROM sys.objects WHERE object_id = CAST(@Object_Name as NUMERIC);   ELSE    SELECT TOP 1 @Object_Type = Type, @Object_Id = Object_Id    FROM sys.objects WHERE object_id = OBJECT_ID(@Object_Name) or name = @Object_Name;     IF @Object_Type COLLATE database_default in  (''TR'', ''FN'', ''P'', ''V'', ''FS'', ''FT'', ''IF'')   BEGIN      SELECT @Object_Name = N''['' + SCHEMA_NAME(SCHEMA_ID) + N''].['' + name + N'']''    FROM sys.objects WHERE object_id = @Object_Id;      SET @SQL = ''EXEC sp_help '''''' + @Object_Name + '''''';'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);      SET @SQL = ''DECLARE @ObjectText nvarchar(MAX)='''''''';     DECLARE @SyscomText nvarchar(MAX);     DECLARE @LineLen INT;     DECLARE @LineEnd BIT = 0;     DECLARE @CommentText TABLE(LineId int IDENTITY(1,1),Text nvarchar(MAX) ''     + CASE WHEN @V > 10 THEN '' collate catalog_default'' ELSE '''' END + '')       DECLARE ms_crs_syscom  CURSOR LOCAL FOR     SELECT text FROM sys.syscomments     WHERE id = '' + CAST(@Object_Id as VARCHAR) + '' and encrypted = 0     ORDER BY number, colid     FOR READ ONLY       OPEN ms_crs_syscom     FETCH NEXT from ms_crs_syscom into @SyscomText       WHILE @@fetch_status >= 0     BEGIN      SET @LineLen = CHARINDEX(CHAR(10),@SyscomText);      WHILE @LineLen > 0      BEGIN         SELECT @ObjectText += LEFT(@SyscomText,@LineLen)        , @SyscomText = SUBSTRING(@SyscomText, @LineLen+1, 4000)        , @LineLen = CHARINDEX(CHAR(10),@SyscomText)        , @LineEnd = 1;           INSERT INTO @CommentText(Text)       VALUES (@ObjectText)         SET @ObjectText = '''''''';      END        IF @LineLen = 0       SET @ObjectText += @SyscomText;      ELSE       SELECT @ObjectText = @SyscomText        , @LineLen = 0;        FETCH NEXT from ms_crs_syscom into @SyscomText     END       CLOSE  ms_crs_syscom;     DEALLOCATE  ms_crs_syscom;       INSERT INTO @CommentText(Text)     SELECT @ObjectText;          SELECT REPLACE(REPLACE(Text,CHAR(10),''''''''),CHAR(13),'''''''') AS text     FROM @CommentText     ORDER BY LineId     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);   END     /* Reporting Tables */   ELSE IF @Object_Type COLLATE database_default IN (''U'',''S'')   BEGIN    SELECT @Object_Name = N''['' + SCHEMA_NAME(SCHEMA_ID) + N''].['' + name + N'']''    FROM sys.objects WHERE object_id = @Object_Id;      SET @SQL = ''EXEC sp_spaceused '''''' + @Object_Name + '''''';'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);      IF (SELECT IDENT_CURRENT(@Object_Name)) IS NOT NULL    BEGIN     SET @SQL = ''SELECT [Last_Identity_Value] = IDENT_CURRENT('''''' + @Object_Name + '''''');'';     PRINT @SQL;     PRINT @S;     EXEC (@SQL);    END      SET @SQL = ''EXEC sp_help '''''' + @Object_Name + '''''';'';    PRINT @SQL;    EXEC (@SQL);    PRINT @S;    /* Partition information */   IF EXISTS (    SELECT TOP 1 1 FROM sys.indexes i    INNER JOIN sys.partition_schemes ps on ps.data_space_id = i.data_space_id    WHERE i.object_id = @Object_Id   )   BEGIN    SET @SQL = ''SELECT    s.name as [Schema], o.name as Table_Name, IsNull(i.name,''''HEAP'''') as Index_Name    , ps.name as Partition_Schema, pf.name as Partition_Function    , pf.modify_date as Last_Modified, PA.partition_number as [Partition]    , CASE pf.boundary_value_on_right WHEN 0 THEN ''''LEFT'''' ELSE ''''RIGHT'''' END as Function_Type    , R1.value as Min_Border_Value, R2.value as Max_Border_Value    , FG.name as [FileGroup_Name], PA.rows    , SUM(AU.total_pages) as total_pages, SUM(AU.used_pages) as used_pages, SUM(AU.data_pages) as data_pages    , sf.name as [File_Name], sf.filename as Physical_File_Name    FROM sys.indexes as i with (NOLOCK)    INNER JOIN sys.partition_schemes as ps with (NOLOCK) on ps.data_space_id = i.data_space_id    INNER JOIN sys.partition_functions as pf with (NOLOCK) on pf.function_id = ps.function_id    INNER JOIN sys.partitions AS PA with (NOLOCK)     ON PA.object_id = i.object_id AND PA.index_id = i.index_id    INNER JOIN sys.allocation_units AS AU with (NOLOCK)     ON (AU.type IN (1, 3) AND AU.container_id = PA.hobt_id)      OR (AU.type = 2 AND AU.container_id = PA.partition_id)    INNER JOIN sys.objects AS o with (NOLOCK) ON i.object_id = o.object_id    INNER JOIN sys.schemas AS s with (NOLOCK) ON o.schema_id = s.schema_id    INNER JOIN sys.filegroups AS FG with (NOLOCK) ON FG.data_space_id = AU.data_space_id    INNER JOIN sys.sysfiles AS sf with (NOLOCK) ON sf.groupid = AU.data_space_id    LEFT JOIN sys.partition_range_values as R1 with (NOLOCK) ON R1.function_id = pf.function_id and R1.boundary_id + 1 = PA.partition_number    LEFT JOIN sys.partition_range_values as R2 with (NOLOCK) ON R2.function_id = pf.function_id and R2.boundary_id = PA.partition_number    WHERE o.object_id = '' + CAST(@Object_Id as NVARCHAR) + ''    GROUP BY s.name, o.name, i.name, PA.partition_number, R1.value, R2.value    , ps.name, pf.name, pf.boundary_value_on_right, pf.modify_date, FG.name, PA.rows, sf.name, sf.filename    ORDER BY o.name, PA.partition_number    OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);   END       IF EXISTS (SELECT TOP 1 1 FROM sys.triggers with (NOLOCK) WHERE parent_id = @Object_Id)   BEGIN    SET @SQL = ''SELECT tr.name as [Trigger Name], te.type_desc     FROM sys.triggers as tr with (NOLOCK)     INNER JOIN sys.trigger_events as te with (NOLOCK) on tr.object_id = te.object_id     WHERE tr.parent_id = '' + CAST(@Object_Id as NVARCHAR) + ''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);   END      /* Table''s Index major stats */    SET @SQL = N''     SELECT [Object Name] = ''''['''' + OBJECT_SCHEMA_NAME('' + CAST(@Object_Id as NVARCHAR) + '')       + ''''].['''' + OBJECT_NAME('' + CAST(@Object_Id as NVARCHAR) + '') + '''']''''      , [Index ID] = p.index_id      , [Compression Type] = p.data_compression_desc      , [Alloc Unit ID] = a.allocation_unit_id      , [Alloc Unit Type] = a.type_desc      , [Partition] = p.partition_number      , [First Page] = CAST(CAST(REVERSE(a.[first_page]) as binary(6)) as INT)      , [Root Page] = CAST(CAST(REVERSE(a.[root_page]) as binary(6)) as INT)      , [First IAM Page] = CAST(CAST(REVERSE(a.[first_iam_page]) as binary(6)) as INT)     FROM sys.system_internals_allocation_units AS a with (NOLOCK)     INNER JOIN sys.partitions AS p with (NOLOCK) on a.[container_id] = p.[partition_id]     WHERE p.[object_id] = '' + CAST(@Object_Id as NVARCHAR) + ''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);       END     IF /*OBJECTPROPERTY(OBJECT_ID(@Object_Name), ''IsPrimaryKey'') = 1*/ @Object_Type COLLATE database_default = ''PK''   BEGIN    DECLARE @ParentID INT;      SELECT @ParentID = parent_object_id FROM sys.objects WHERE object_id = @Object_Id;    /*PRIMARY KEY*/    /* 1. General Info */    SET @SQL = ''SELECT ''''PRIMARY KEY'''' as [Type]     , OBJECT_SCHEMA_NAME('' + CAST(@ParentID as NVARCHAR) + '') + ''''.'''' + OBJECT_NAME('' + CAST(@ParentID as NVARCHAR) + '') as Table_Name     , i.name as Primary_Key_Name, i.type_desc, i.index_id     , CASE i.fill_factor WHEN 0 THEN 100 ELSE i.fill_factor END as fill_factor, o.create_date, o.modify_date     FROM sys.indexes as i with (NOLOCK)     INNER JOIN sys.objects as o with (NOLOCK) ON o.parent_object_id = i.object_id     WHERE o.type = ''''PK'''' and o.object_id = '' + CAST(@Object_Id as NVARCHAR) + '' and i.name = '''''' + @Object_Name + ''''''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);      /* 2. References */    SET @SQL = ''SELECT RO.name as Referenced_Table, FK.Name as Foreign_Key_Name, FK.create_date, FK.modify_date     FROM sys.objects AS PK with (NOLOCK)     INNER JOIN sys.foreign_keys as FK with (NOLOCK) ON FK.referenced_object_id = PK.parent_object_id     INNER JOIN sys.objects as RO with (NOLOCK) ON FK.parent_object_id = RO.object_id     WHERE PK.name = '''''' + @Object_Name + ''''''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);   END /*PRIMARY KEY*/     ELSE IF /*OBJECTPROPERTY(OBJECT_ID(@Object_Name), ''IsForeignKey'') = 1*/ @Object_Type COLLATE database_default = ''F''   BEGIN    /* FOREIGN KEY */    /* 1. General Info */    SET @SQL = ''SELECT ''''FOREIGN KEY'''' as [Type],       OBJECT_NAME(parent_object_id) as Table_Name,       SCHEMA_NAME(schema_id) as [Schema_Name],       name as Foreign_Key_Name,       OBJECT_NAME(referenced_object_id) as Referenced_Table,       Is_disabled, is_not_trusted,        create_date, modify_date,       object_id, parent_object_id, referenced_object_id     FROM sys.foreign_keys with (NOLOCK)     WHERE name = '''''' + @Object_Name + ''''''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);      /* 2. FK Columns */    SET @SQL = ''SELECT OBJECT_NAME(fc.constraint_object_id) as Constraint_Object      , OBJECT_NAME(fc.parent_object_id) as Parent_Object      , COL_NAME(fc.parent_object_id, fc.parent_column_id) as Column_Name      , t.name, c.max_length, c.is_nullable      , OBJECT_NAME(fc.referenced_object_id) as Referenced_Object      , COL_NAME(fc.referenced_object_id, fc.referenced_column_id) as Referenced_Column     FROM sys.foreign_key_columns as fc with (NOLOCK)     INNER JOIN sys.foreign_keys as fk with (NOLOCK) on fk.object_id = fc.constraint_object_id     INNER JOIN sys.columns as c with (NOLOCK) on fc.parent_object_id = c.object_id and fc.parent_column_id = c.column_id     INNER JOIN sys.types as t with (NOLOCK) on c.system_type_id = t.system_type_id     WHERE fk.name = '''''' + @Object_Name + ''''''     ORDER BY fc.constraint_column_id     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);      /* Referencing Primary Key */    SET @SQL = ''     SELECT OBJECT_SCHEMA_NAME(PK.parent_object_id) + ''''.'''' + OBJECT_NAME(PK.parent_object_id) as Referencing_Table      , PK.name as Referenced_Primary_Key, PK.create_date, PK.modify_date, FK.Name as Foreign_Key_Name     FROM sys.objects AS PK with (NOLOCK)     INNER JOIN sys.foreign_keys as FK with (NOLOCK) ON FK.referenced_object_id = PK.parent_object_id     /* INNER JOIN sys.objects as RO ON PK.parent_object_id = RO.object_id */     WHERE FK.Name = '''''' + @Object_Name + '''''' and PK.type = ''''PK''''     OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);     END /* FOREIGN KEY */     /* Report Index or table allocation */   IF EXISTS (SELECT TOP 1 1 FROM sys.indexes WHERE name = @Object_Name) or @Object_Type COLLATE database_default =''U''   BEGIN    SET @SQL = ''SELECT OBJECT_NAME(i.OBJECT_ID) AS TableName,     i.name AS TableIndexName,     ps.index_id,     ps.index_level,     ps.index_type_desc,     ps.alloc_unit_type_desc,     ps.index_depth index_level,     CASE WHEN i.fill_factor = 0 OR (ps.index_level > 0 and i.is_padded = 0)     THEN 100 ELSE i.fill_factor END AS fill_factor,     ROUND(ps.avg_fragmentation_in_percent,3) as [AVG Frgmnt %],     ROUND(ps.avg_page_space_used_in_percent,3) as [AVG Space Use %],     ps.fragment_count,     ROUND(ps.avg_fragment_size_in_pages,3) as [AVG Frgmnt Size],     ps.page_count,     CAST(ps.page_count/128. as NUMERIC(19,3)) as [Index Size Mb],     ps.record_count,     (ps.record_count / ps.page_count) as AVG_Records_per_Page,     ps.ghost_record_count,     ps.forwarded_record_count    FROM sys.dm_db_index_physical_stats(''     /*Specifying Current Database */     + CAST(DB_ID() AS VARCHAR) + '', ''     /*Specifying Table*/     + CAST(@ParentID as VARCHAR) + '', ''     /*Specifying Index*/     + IsNull(CAST(@Index_Id as VARCHAR),''NULL'')     /*Specifying Reporting Mode*/       + '', NULL, '''''' + @Parameter2 COLLATE database_default + '''''') ps    INNER JOIN sys.indexes i with (NOLOCK) ON i.OBJECT_ID = ps.OBJECT_ID AND i.index_id = ps.index_id    WHERE i.name = '''''' + @Object_Name + ''''''    OPTION (RECOMPILE);'';    PRINT @SQL;    PRINT @S;    EXEC (@SQL);   END /* Report Index or table allocation */    END /* @Object_Name Is NOT Null */    RETURN;  ');  EXEC('  EXEC #USP_HELP   ');  EXEC(' ');


-----------------------------------------------------------------------------------------------


Ctrl+9:
/* Index Info */ EXEC (' IF OBJECT_ID(''tempdb..#USP_GETINDEX'') IS NOT NULL  DROP PROCEDURE #USP_GETINDEX; ');  EXEC(' CREATE PROCEDURE #USP_GETINDEX @Object_Name SYSNAME = NULL WITH RECOMPILE AS SET NOCOUNT ON DECLARE @oid INT, @iid INT; DECLARE @S CHAR(80); DECLARE @V INT; /* SQL Server Major Version */  SELECT @V = CAST(CAST(SERVERPROPERTY(''ProductVersion'') as CHAR(2)) as NUMERIC)  , @S = REPLICATE(''-'',80);  PRINT ''Function Ctrl-4: SQL Server Index Troubleshooting.''; PRINT ''1. No options: Returns following: ''; PRINT ''   - Lists of TOP 10 Not-Used Indexes and TOP 10 Missing Indexes.''; PRINT ''   - Lists of TOP 10 Missing Indexes.''; PRINT ''   - Lists of all non-empty indexes sorted by fragmentation impact.''; PRINT ''   Disclosure A: Lists are valid only after full regular business workload cycle. Without SQL Server Reboots and Index Maintenance.''; PRINT ''   Disclosure B: Before applying Missing Indexes, always check if any similar index exist. Maybe you can just simply modify an existing one.''; PRINT ''2. Table Name: Returns Tables'''' Indexes Usage Statistics and possible missing indexes.''; PRINT ''3. Index Name: Returns Index Usage Statistics and general info.''; RAISERROR (@S,10,1) WITH NOWAIT  If @Object_Name COLLATE database_default Is not Null  PRINT ''Used Parameter: '' + @Object_Name + '''';  DECLARE @SQL NVARCHAR(MAX);  DECLARE @Top10Unused  NVARCHAR(MAX) = ''SELECT TOP 10 Table_Name = t.name   , Last_Object_Modification = t.modify_date   , [Bad Index Name] = i.name   , i.index_id   '' + CASE WHEN @V > 10 THEN '', ps.Page_Count'' ELSE '''' END +   '', [Indexed Columns] = SUBSTRING(    (    SELECT '''', '''' + c.name    FROM sys.index_columns as ic    INNER JOIN sys.columns as c ON c.object_id = ic.object_id and ic.column_id = c.column_id    WHERE ic.object_id = s.object_id  and ic.index_id = s.index_id and ic.is_included_column = 0    FOR XML PATH('''''''')    ),3,2147483647     )   , [Included Columns] = SUBSTRING(IsNull(    (    SELECT '''', '''' + c.name    FROM sys.index_columns as ic    INNER JOIN sys.columns as c ON c.object_id = ic.object_id and ic.column_id = c.column_id    WHERE ic.object_id = s.object_id  and ic.index_id = s.index_id and ic.is_included_column = 1    FOR XML PATH('''''''')    ),''''''''),3,2147483647     )   , Total_Writes =  s.user_updates   , Total_Reads = s.user_seeks + s.user_scans + s.user_lookups   , Factor = (s.user_updates - s.user_seeks - s.user_scans - s.user_lookups - 1.) / s.user_updates  FROM sys.dm_db_index_usage_stats AS s  INNER JOIN sys.indexes AS i ON s.object_id = i.object_id AND i.index_id = s.index_id  INNER JOIN sys.tables as t on i.[object_id] = t.[object_id]  '' + CASE WHEN @V > 10 THEN ''CROSS APPLY sys.dm_db_index_physical_stats(DB_ID(), i.object_id, i.index_id, NULL, ''''LIMITED'''') as ps'' ELSE '''' END + ''  INNER JOIN sys.dm_db_index_operational_stats (DB_ID(),NULL,NULL,NULL ) o   ON i.[object_id] = o.[object_id] AND i.index_id = o.index_id  WHERE objectproperty(s.object_id,''''IsUserTable'''') = 1  AND s.database_id = db_id()  AND s.user_updates > (s.user_seeks + s.user_scans + s.user_lookups)  AND NOT (o.leaf_insert_count = 0'' + CASE WHEN @V > 10 THEN '' and ps.Page_Count = 0'' ELSE '''' END + '')  ORDER BY Factor DESC  OPTION (RECOMPILE);'';  /* -- Glenn Berry -- http://sqlserverperformance.wordpress.com/2007/11/29/useful-tricks-for-finding-missing-and-bad-indexes-in-sql-server-2005/ */ DECLARE @Top10Missing  NVARCHAR(MAX) = ''SELECT TOP 10   Affected_Table = t.name   , SQL_Statement = ''''CREATE NONCLUSTERED INDEX NCIX_'''' + t.name COLLATE DATABASE_DEFAULT + ''''_''''    + REPLACE(REPLACE(REPLACE(IsNull(mid.equality_columns,mid.inequality_columns), ''''], ['''', ''''_''''), ''''['''', ''''''''),'''']'''', '''''''')    + '''' ON '''' + mid.STATEMENT + '''' ('''' + IsNull(mid.equality_columns,'''''''')    + CASE WHEN mid.equality_columns IS Not Null     And mid.inequality_columns IS Not Null THEN '''','''' ELSE '''''''' END    + IsNull(mid.inequality_columns, '''''''')    + '''')'''' + IsNull('''' Include ('''' + mid.included_columns + '''');'''', '''';'''')   , Estimated_Impact = CAST( (migs.user_seeks + migs.user_scans )    * migs.avg_user_impact * migs.avg_total_user_cost / 100 AS INT)   , Equality_Columns = IsNull(mid.equality_columns,'''''''')   , Inequality_Columns = IsNull(mid.inequality_columns,'''''''')   , Included_Columns = IsNull(mid.included_columns,'''''''')  FROM sys.dm_db_missing_index_groups AS mig  INNER Join sys.dm_db_missing_index_group_stats AS migs   ON migs.group_handle = mig.index_group_handle  INNER Join sys.dm_db_missing_index_details AS mid   ON mig.index_handle = mid.index_handle  INNER Join sys.tables AS t ON mid.object_id = t.object_id  WHERE mid.database_id = DB_ID()'';  DECLARE @IndexUsage  NVARCHAR(MAX) = ''SELECT OBJECT_NAME(i.object_id) AS [OBJECT NAME],  t.modify_date as Last_Object_Modification,  [INDEX NAME]=ISNUll(i.name,''''HEAP-''''+ps.alloc_unit_type_desc)  '' + CASE WHEN @V > 10 THEN '', ps.Page_Count'' ELSE '''' END +  '',o.partition_number  ,[Indexed Columns] = SUBSTRING(   (SELECT '''', '''' + c.name   FROM sys.index_columns as ic   INNER JOIN sys.columns as c ON c.object_id = ic.object_id and ic.column_id = c.column_id   WHERE ic.object_id = i.object_id  and ic.index_id = i.index_id and ic.is_included_column = 0   FOR XML PATH('''''''')   ),3,2147483647)  ,[Included Columns]=SUBSTRING(IsNull(   (SELECT '''', '''' + c.name   FROM sys.index_columns as ic   INNER JOIN sys.columns as c ON c.object_id = ic.object_id and ic.column_id = c.column_id   WHERE ic.object_id = i.object_id  and ic.index_id = i.index_id and ic.is_included_column = 1   FOR XML PATH('''''''')   ),''''''''),3,2147483647)  ,u.USER_SEEKS  ,u.USER_SCANS  ,u.USER_LOOKUPS  ,u.USER_UPDATES  ,o.LEAF_INSERT_COUNT  ,o.LEAF_UPDATE_COUNT  ,o.LEAF_DELETE_COUNT  ,u.last_user_seek  ,u.last_user_scan  ,u.last_user_lookup  ,u.last_user_update  ,u.last_system_seek  ,u.last_system_scan  ,u.last_system_lookup  ,u.last_system_update FROM sys.indexes AS i with (nolock) INNER JOIN sys.dm_db_index_operational_stats(DB_ID(),NULL,NULL,NULL ) o  ON i.object_id = o.object_id AND i.index_id = o.index_id INNER JOIN sys.tables as t with (nolock) on i.object_id = t.object_id '' + CASE WHEN @V > 10 THEN ''CROSS APPLY sys.dm_db_index_physical_stats(DB_ID(), i.object_id, i.index_id, o.partition_number, ''''LIMITED'''') as ps'' ELSE '''' END + '' INNER JOIN sys.dm_db_index_usage_stats AS u with (nolock)  ON i.object_id = u.object_id AND i.index_id = u.index_id and u.database_id = DB_ID() '';  IF @Object_Name COLLATE database_default Is Null BEGIN  /* Lists of TOP 10 Not-Used Indexes */  PRINT @Top10Unused;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@Top10Unused);   /* Lists of TOP 10 Missing Indexes */  SET @Top10Missing += '' ORDER BY ''''Estimated_Impact'''' DESC OPTION (RECOMPILE);'';  PRINT @Top10Missing;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@Top10Missing);   IF  @V > 10  BEGIN   /* Report page fragmentation/allocation for all Indexes sorted by fragmentation impact */   SET @SQL = '';WITH IndexData as ( SELECT  OBJECT_SCHEMA_NAME(ps.object_id) as [Schema Name],  OBJECT_NAME(ps.object_id) as [Table Name],  i.name as [Index Name],  i.index_id,  IsNull(idnt.yn,''''No'''') as [Identity],  CASE i.fill_factor WHEN 0 THEN (   SELECT CASE [value] WHEN 0 THEN [maximum] ELSE [value] END   FROM master.sys.configurations WHERE name = ''''fill factor (%)''''   ) ELSE i.fill_factor END as fill_factor,  CAST(ROUND(ps.avg_fragmentation_in_percent,3) as Decimal(9,3)) as [Avg Frag %],  ps.fragment_count as [Fragments],  ps.record_count as [Records],  ps.page_count as [Pages],  CAST(ROUND(ps.avg_page_space_used_in_percent,3) as Decimal(9,3)) as [Avg page use %],  CAST(ROUND(ps.page_count / 128.,3) as Decimal(9,3)) AS [Data Space, Mb],  CAST(ROUND(ps.page_count * ps.avg_page_space_used_in_percent / 12800.,3) as Decimal(9,3)) as [Space Used, Mb],  CAST(ROUND(ps.page_count * (100 - ps.avg_page_space_used_in_percent) / 12800.,3) as Decimal(9,3)) as [Reserved, Mb],  CAST(ROUND(100 - ps.avg_page_space_used_in_percent * 100  / (CASE i.fill_factor WHEN 0 THEN 100 ELSE i.fill_factor END),3) as Decimal(9,3)) as [Space Overuse %] FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, ''''SAMPLED'''') ps INNER JOIN sys.indexes i ON i.OBJECT_ID = ps.OBJECT_ID AND i.index_id = ps.index_id OUTER APPLY (  SELECT ''''Yes'''' FROM sys.index_columns as ic  INNER JOIN sys.columns as c   ON i.object_id = c.object_id and ic.column_id = c.column_id  WHERE c.is_identity = 1 and ic.index_column_id = 1 and   i.object_id = ic.object_id and i.index_id = ic.index_id ) as idnt(yn) WHERE ps.page_count > 1 and ps.avg_fragmentation_in_percent > 0 ), TotalPages as (SELECT SUM([Pages]) as TotalPages FROM IndexData) SELECT  [Schema Name], [Table Name], [Index Name], [index_id], [Identity]  , [fill_factor], [Avg Frag %], [Fragments], [Records], [Pages]  , [Avg page use %], [Data Space, Mb], [Space Used, Mb], [Reserved, Mb], [Space Overuse %] FROM IndexData, TotalPages ORDER BY [Pages]*[Avg Frag %]/TotalPages DESC OPTION (RECOMPILE);''    PRINT @SQL;   RAISERROR (@S,10,1) WITH NOWAIT   EXEC (@SQL);  END END ELSE IF OBJECTPROPERTY(Object_ID(@Object_Name),''IsTable'') = 1 BEGIN  /* Tables Indexes Usage Statistics */  SET @IndexUsage += '' WHERE i.object_id = OBJECT_ID('''''' + @Object_Name   + '''''') ORDER BY i.index_id DESC OPTION (RECOMPILE);'';  PRINT @IndexUsage;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@IndexUsage);   /* Lists of TOP 10 Missing Indexes for a table */  SET @Top10Missing += '' and t.object_id = OBJECT_ID('''''' + @Object_Name + '''''') ORDER BY ''''Estimated_Impact'''' DESC OPTION (RECOMPILE);'';  PRINT @Top10Missing;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@Top10Missing);  END ELSE IF EXISTS ( SELECT TOP 1 1 FROM sys.indexes WHERE name = @Object_Name) BEGIN /* Report Index */   SELECT @oid = object_id, @iid = index_id  FROM sys.indexes  WHERE name = @Object_Name   SET @SQL = ''SELECT ''''INDEX'''' as [Object Type]  , SCHEMA_NAME(o.schema_id) as [Schema_Name]  , o.Name as [Table/View Name]  , i.name as Index_Name  , i.type_desc  , CASE i.is_Unique WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Is_Unique  , CASE i.ignore_dup_key WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Ignore_Dup_Key  , CASE i.fill_factor when 0 then 100 ELSE i.fill_factor END Fill_Factor  , CASE i.is_disabled WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Is_Disabled  , CASE i.has_filter WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Has_Filter  , IsNull(i.filter_definition,'''''''') as Filter_Definition  , i.object_id  , i.index_id  FROM sys.indexes as i  INNER JOIN sys.objects AS o on o.object_id = i.object_id  WHERE i.index_id = '' + CAST(@iid as VARCHAR) + '' and i.object_id = '' + CAST(@oid as VARCHAR) + ''  OPTION (RECOMPILE);'';  PRINT @SQL;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);    SET @SQL = ''SELECT c.name as Index_Column  , CASE ic.is_included_column WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Included  , CASE c.is_nullable WHEN 0 THEN ''''No'''' ELSE ''''Yes'''' END as Is_Nullable  , t.name as Column_Type  , c.max_length  , c.precision  , c.scale  , c.collation_name  FROM sys.indexes as i  INNER JOIN sys.objects AS o on o.object_id = i.object_id  INNER JOIN sys.index_columns as ic on ic.object_id = i.object_id and i.index_id = ic.index_id  INNER JOIN sys.columns as c on c.object_id = i.object_id and ic.column_id = c.column_id  INNER JOIN sys.types as t ON t.system_type_id =c.system_type_id  WHERE i.index_id = '' + CAST(@iid as VARCHAR) + '' and i.object_id = '' + CAST(@oid as VARCHAR) + ''  OPTION (RECOMPILE);'';  PRINT @SQL;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   /* Report Index allocation */  SET @SQL = ''SELECT OBJECT_NAME('' + CAST(@oid as VARCHAR) + '') AS TableName,   i.name AS TableIndexName,   ps.index_id,   ps.index_level,   ps.index_type_desc,   ps.alloc_unit_type_desc,   ps.index_depth index_level,   CASE WHEN i.fill_factor = 0 OR (ps.index_level > 0 and i.is_padded = 0)   THEN 100 ELSE i.fill_factor END AS fill_factor,   ROUND(ps.avg_fragmentation_in_percent,3) as [AVG Frgmnt %],   ROUND(ps.avg_page_space_used_in_percent,3) as [AVG Space Use %],   ps.fragment_count,   ROUND(ps.avg_fragment_size_in_pages,3) as [AVG Frgmnt Size],   ps.page_count,   CAST(ps.page_count/128. as NUMERIC(19,3)) as [Index Size Mb],   ps.record_count,   CASE WHEN ps.page_count = 0 THEN 0 ELSE (ps.record_count / ps.page_count) END as AVG_Records_per_Page,   ps.ghost_record_count,   ps.forwarded_record_count  FROM sys.indexes i  CROSS APPLY sys.dm_db_index_physical_stats(DB_ID(), '' + CAST(@oid as VARCHAR) + '', '' + CAST(@iid as VARCHAR) + '', NULL, ''''DETAILED'''') ps  WHERE i.index_id = '' + CAST(@iid as VARCHAR) + '' and i.object_id = '' + CAST(@oid as VARCHAR) + ''  OPTION (RECOMPILE);'';  PRINT @SQL;  RAISERROR (@S,10,1) WITH NOWAIT  EXEC (@SQL);   /* Report Index usage */  SET @IndexUsage += '' WHERE i.name = '''''' + @Object_Name + '''''' OPTION (RECOMPILE);''  PRINT @IndexUsage;  EXEC (@IndexUsage);   IF  @V > 10  BEGIN   /* Report Index page allocation */   SET @SQL = ''SELECT DB_NAME() as Database_Name,    OBJECT_NAME(i.object_id)  as Table_Name,    i.Index_id,    a.allocation_unit_type,    a.allocation_unit_type_desc,    a.allocated_page_iam_file_id,    a.extent_file_id,    a.extent_page_id,    a.allocated_page_page_id,    a.is_allocated,    a.is_iam_page,    a.is_mixed_page_allocation,    a.page_type,    a.page_type_desc,    a.page_level,    a.next_page_page_id,    a.previous_page_page_id,    a.is_page_compressed   FROM sys.indexes AS i   CROSS APPLY sys.dm_db_database_page_allocations(DB_ID(),'' + CAST(@oid as VARCHAR) + '', '' + CAST(@iid as VARCHAR) + '', NULL, ''''DETAILED'''') a   WHERE i.index_id = '' + CAST(@iid as VARCHAR) + '' and i.object_id = '' + CAST(@oid as VARCHAR) + ''   ORDER BY a.page_level DESC, a.previous_page_page_id, a.extent_page_id, a.allocated_page_page_id   OPTION (RECOMPILE);'';   PRINT @SQL;   RAISERROR (@S,10,1) WITH NOWAIT   EXEC (@SQL);  END  END /* Report Index */  ELSE  PRINT ''No objects found with a name: '' + @Object_Name + ''.''  RETURN 0; ');  EXEC(' EXEC #USP_GETINDEX ');  EXEC(' ');



-----------------------------------------------------------------------------------------------


Ctrl+0:
/* Who Info */  EXEC ('  SET QUOTED_IDENTIFIER OFF  '); EXEC ('   CREATE OR ALTER PROCEDURE ##USP_BLITZWHO    @ShowSleepingSPIDs TINYINT = 0,   @ExpertMode BIT = 0,   @Debug BIT = 0,   @OutputTableRetentionDays TINYINT = 3 ,   @MinElapsedSeconds INT = 0 ,   @MinCPUTime INT = 0 ,   @MinLogicalReads INT = 0 ,   @MinPhysicalReads INT = 0 ,   @MinWrites INT = 0 ,   @MinTempdbMB INT = 0 ,   @MinRequestedMemoryKB INT = 0 ,   @MinBlockingSeconds INT = 0  AS  BEGIN   SET NOCOUNT ON;   SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;            /* Get the major and minor build numbers */      DECLARE  @ProductVersion NVARCHAR(128)        ,@ProductVersionMajor DECIMAL(10,2)        ,@ProductVersionMinor DECIMAL(10,2)        ,@EnhanceFlag BIT = 0        ,@BlockingCheck NVARCHAR(MAX)        ,@StringToSelect NVARCHAR(MAX)        ,@StringToExecute VARCHAR(MAX)        ,@OutputTableCleanupDate DATE        ,@SessionWaits BIT = 0        ,@SessionWaitsSQL NVARCHAR(MAX) =              N''LEFT JOIN ( SELECT DISTINCT                  wait.session_id ,                  ( SELECT TOP  5 waitwait.wait_type + N'''' (''''                       + CAST(MAX(waitwait.wait_time_ms) AS NVARCHAR(128))                       + N'''' ms), ''''                   FROM   sys.dm_exec_session_wait_stats AS waitwait                   WHERE  waitwait.session_id = wait.session_id                   GROUP BY  waitwait.wait_type                   HAVING SUM(waitwait.wait_time_ms) > 5                   ORDER BY 1                                FOR                   XML PATH('''''''') ) AS session_wait_info                FROM sys.dm_exec_session_wait_stats AS wait ) AS wt2            ON   s.session_id = wt2.session_id            LEFT JOIN sys.dm_exec_query_stats AS session_stats            ON   r.sql_handle = session_stats.sql_handle              AND r.plan_handle = session_stats.plan_handle              AND r.statement_start_offset = session_stats.statement_start_offset              AND r.statement_end_offset = session_stats.statement_end_offset''         ,@QueryStatsXMLselect NVARCHAR(MAX) = N'' CAST(COALESCE(qs_live.query_plan, ''''<?No live query plan available. To turn on live plans, see https://www.BrentOzar.com/go/liveplans ?>'''') AS XML) AS live_query_plan , ''         ,@QueryStatsXMLSQL NVARCHAR(MAX) = N''OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live''           SET @ProductVersion = CAST(SERVERPROPERTY(''ProductVersion'') AS NVARCHAR(128));      SELECT @ProductVersionMajor = SUBSTRING(@ProductVersion, 1,CHARINDEX(''.'', @ProductVersion) + 1 ),          @ProductVersionMinor = PARSENAME(CONVERT(VARCHAR(32), @ProductVersion), 2)      IF EXISTS (SELECT * FROM sys.all_columns WHERE object_id = OBJECT_ID(''sys.dm_exec_query_statistics_xml'') AND name = ''query_plan'')       BEGIN        SET @QueryStatsXMLselect = N'' CAST(COALESCE(qs_live.query_plan, ''''<?No live query plan available. To turn on live plans, see https://www.BrentOzar.com/go/liveplans ?>'''') AS XML) AS live_query_plan , '';        SET @QueryStatsXMLSQL = N''OUTER APPLY sys.dm_exec_query_statistics_xml(s.session_id) qs_live'';       END       ELSE       BEGIN        SET @QueryStatsXMLselect = N'' NULL AS live_query_plan , '';        SET @QueryStatsXMLSQL = N'' '';       END        SELECT @BlockingCheck = N''SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;                 DECLARE @blocked TABLE               (                  dbid SMALLINT NOT NULL,                  last_batch DATETIME NOT NULL,                  open_tran SMALLINT NOT NULL,                  sql_handle BINARY(20) NOT NULL,                  session_id SMALLINT NOT NULL,                  blocking_session_id SMALLINT NOT NULL,                  lastwaittype NCHAR(32) NOT NULL,                  waittime BIGINT NOT NULL,                  cpu INT NOT NULL,                  physical_io BIGINT NOT NULL,                  memusage INT NOT NULL              );                     INSERT @blocked ( dbid, last_batch, open_tran, sql_handle, session_id, blocking_session_id, lastwaittype, waittime, cpu, physical_io, memusage )            SELECT             sys1.dbid, sys1.last_batch, sys1.open_tran, sys1.sql_handle,              sys2.spid AS session_id, sys2.blocked AS blocking_session_id, sys2.lastwaittype, sys2.waittime, sys2.cpu, sys2.physical_io, sys2.memusage            FROM sys.sysprocesses AS sys1            JOIN sys.sysprocesses AS sys2            ON sys1.spid = sys2.blocked;'';        IF @ProductVersionMajor > 9 and @ProductVersionMajor < 11      BEGIN          /* Think of the StringToExecute as starting with this, but we will set this up later depending on whether we are doing an insert or a select:          SELECT @StringToExecute = N''SELECT  GETDATE() AS run_date ,          */          SET @StringToExecute = N''COALESCE(                 CONVERT(VARCHAR(20), (ABS(r.total_elapsed_time) / 1000) / 86400) + '''':'''' + CONVERT(VARCHAR(20), DATEADD(SECOND, (r.total_elapsed_time / 1000), 0), 114) ,                 CONVERT(VARCHAR(20), DATEDIFF(SECOND, s.last_request_start_time, GETDATE()) / 86400) + '''':''''                  + CONVERT(VARCHAR(20), DATEADD(SECOND,  DATEDIFF(SECOND, s.last_request_start_time, GETDATE()), 0), 114)                  ) AS [elapsed_time] ,                s.session_id ,                COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid), ''''N/A'''') AS database_name,                ISNULL(SUBSTRING(dest.text,                     ( query_stats.statement_start_offset / 2 ) + 1,                     ( ( CASE query_stats.statement_end_offset                        WHEN -1 THEN DATALENGTH(dest.text)                        ELSE query_stats.statement_end_offset                      END - query_stats.statement_start_offset )                       / 2 ) + 1), dest.text) AS query_text ,                derp.query_plan ,                qmg.query_cost ,                                  s.status ,                COALESCE(wt.wait_info, RTRIM(blocked.lastwaittype) + '''' ('''' + CONVERT(VARCHAR(10),                 blocked.waittime) + '''')'''' ) AS wait_info ,                           CASE WHEN r.blocking_session_id <> 0 AND blocked.session_id IS NULL                   THEN r.blocking_session_id                  WHEN r.blocking_session_id <> 0 AND s.session_id <> blocked.blocking_session_id                   THEN blocked.blocking_session_id                 ELSE NULL                 END AS blocking_session_id ,                 COALESCE(r.open_transaction_count, blocked.open_tran) AS open_transaction_count ,                CASE WHEN EXISTS (  SELECT 1                      FROM sys.dm_tran_active_transactions AS tat                     JOIN sys.dm_tran_session_transactions AS tst                     ON tst.transaction_id = tat.transaction_id                     WHERE tat.name = ''''implicit_transaction''''                     AND s.session_id = tst.session_id                      )  THEN 1                   ELSE 0                 END AS is_implicit_transaction ,                s.nt_domain ,                s.host_name ,                s.login_name ,                s.nt_user_name ,                s.program_name                ''                  IF @ExpertMode = 1          BEGIN          SET @StringToExecute +=             N'',            ''''DBCC FREEPROCCACHE ('''' + CONVERT(NVARCHAR(128), r.plan_handle, 1) + '''');'''' AS fix_parameter_sniffing,                          s.client_interface_name ,            s.login_time ,            r.start_time ,            qmg.request_time ,            COALESCE(r.cpu_time, s.cpu_time) AS request_cpu_time,            COALESCE(r.logical_reads, s.logical_reads) AS request_logical_reads,            COALESCE(r.writes, s.writes) AS request_writes,            COALESCE(r.reads, s.reads) AS request_physical_reads ,            s.cpu_time AS session_cpu,            s.logical_reads AS session_logical_reads,            s.reads AS session_physical_reads ,            s.writes AS session_writes,                 tempdb_allocations.tempdb_allocations_mb,            s.memory_usage ,            r.estimated_completion_time ,              r.percent_complete ,             r.deadlock_priority ,            CASE               WHEN s.transaction_isolation_level = 0 THEN ''''Unspecified''''              WHEN s.transaction_isolation_level = 1 THEN ''''Read Uncommitted''''              WHEN s.transaction_isolation_level = 2 AND EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''''Read Committed Snapshot Isolation''''              WHEN s.transaction_isolation_level = 2 AND NOT EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''''Read Committed''''              WHEN s.transaction_isolation_level = 3 THEN ''''Repeatable Read''''              WHEN s.transaction_isolation_level = 4 THEN ''''Serializable''''              WHEN s.transaction_isolation_level = 5 THEN ''''Snapshot''''              ELSE ''''WHAT HAVE YOU DONE?''''            END AS transaction_isolation_level ,                qmg.dop AS degree_of_parallelism ,            COALESCE(CAST(qmg.grant_time AS VARCHAR(20)), ''''N/A'''') AS grant_time ,            qmg.requested_memory_kb ,            qmg.granted_memory_kb AS grant_memory_kb,            CASE WHEN qmg.grant_time IS NULL THEN ''''N/A''''              WHEN qmg.requested_memory_kb < qmg.granted_memory_kb              THEN ''''Query Granted Less Than Query Requested''''              ELSE ''''Memory Request Granted''''            END AS is_request_granted ,            qmg.required_memory_kb ,            qmg.used_memory_kb AS query_memory_grant_used_memory_kb,            qmg.ideal_memory_kb ,            qmg.is_small ,            qmg.timeout_sec ,            qmg.resource_semaphore_id ,            COALESCE(CAST(qmg.wait_order AS VARCHAR(20)), ''''N/A'''') AS wait_order ,            COALESCE(CAST(qmg.wait_time_ms AS VARCHAR(20)),               ''''N/A'''') AS wait_time_ms ,            CASE qmg.is_next_candidate              WHEN 0 THEN ''''No''''              WHEN 1 THEN ''''Yes''''              ELSE ''''N/A''''            END AS next_candidate_for_memory_grant ,            qrs.target_memory_kb ,            COALESCE(CAST(qrs.max_target_memory_kb AS VARCHAR(20)),               ''''Small Query Resource Semaphore'''') AS max_target_memory_kb ,            qrs.total_memory_kb ,            qrs.available_memory_kb ,            qrs.granted_memory_kb ,            qrs.used_memory_kb AS query_resource_semaphore_used_memory_kb,            qrs.grantee_count ,            qrs.waiter_count ,            qrs.timeout_error_count ,            COALESCE(CAST(qrs.forced_grant_count AS VARCHAR(20)),               ''''Small Query Resource Semaphore'''') AS forced_grant_count,            wg.name AS workload_group_name ,             rp.name AS resource_pool_name,             CONVERT(VARCHAR(128), r.context_info)  AS context_info            ''       END /* IF @ExpertMode = 1 */                SET @StringToExecute +=                ''FROM sys.dm_exec_sessions AS s          LEFT JOIN sys.dm_exec_requests AS r          ON   r.session_id = s.session_id          LEFT JOIN ( SELECT DISTINCT               wait.session_id ,               ( SELECT waitwait.wait_type + '''' (''''                  + CAST(MAX(waitwait.wait_duration_ms) AS NVARCHAR(128))                  + '''' ms) ''''                 FROM   sys.dm_os_waiting_tasks AS waitwait                 WHERE  waitwait.session_id = wait.session_id                 GROUP BY  waitwait.wait_type                 ORDER BY  SUM(waitwait.wait_duration_ms) DESC               FOR                 XML PATH('''''''') ) AS wait_info             FROM sys.dm_os_waiting_tasks AS wait ) AS wt          ON   s.session_id = wt.session_id          LEFT JOIN sys.dm_exec_query_stats AS query_stats          ON   r.sql_handle = query_stats.sql_handle            AND r.plan_handle = query_stats.plan_handle            AND r.statement_start_offset = query_stats.statement_start_offset            AND r.statement_end_offset = query_stats.statement_end_offset          LEFT JOIN sys.dm_exec_query_memory_grants qmg          ON   r.session_id = qmg.session_id            AND r.request_id = qmg.request_id          LEFT JOIN sys.dm_exec_query_resource_semaphores qrs          ON   qmg.resource_semaphore_id = qrs.resource_semaphore_id            AND qmg.pool_id = qrs.pool_id          LEFT JOIN sys.resource_governor_workload_groups wg           ON   s.group_id = wg.group_id          LEFT JOIN sys.resource_governor_resource_pools rp           ON  wg.pool_id = rp.pool_id          OUTER APPLY (              SELECT TOP 1              b.dbid, b.last_batch, b.open_tran, b.sql_handle,               b.session_id, b.blocking_session_id, b.lastwaittype, b.waittime              FROM @blocked b              WHERE (s.session_id = b.session_id                OR s.session_id = b.blocking_session_id)             ) AS blocked              OUTER APPLY sys.dm_exec_sql_text(COALESCE(r.sql_handle, blocked.sql_handle)) AS dest          OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS derp          OUTER APPLY (            SELECT CONVERT(DECIMAL(38,2), SUM( (((tsu.user_objects_alloc_page_count - user_objects_dealloc_page_count) * 8) / 1024.)) ) AS tempdb_allocations_mb            FROM sys.dm_db_task_space_usage tsu            WHERE tsu.request_id = r.request_id            AND tsu.session_id = r.session_id            AND tsu.session_id = s.session_id          ) as tempdb_allocations          WHERE s.session_id <> @@SPID           AND s.host_name IS NOT NULL          ''          + CASE WHEN @ShowSleepingSPIDs = 0 THEN            N'' AND COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid)) IS NOT NULL''             WHEN @ShowSleepingSPIDs = 1 THEN            N'' OR COALESCE(r.open_transaction_count, blocked.open_tran) >= 1''            ELSE N'''' END;      END /* IF @ProductVersionMajor > 9 and @ProductVersionMajor < 11 */        IF @ProductVersionMajor >= 11           BEGIN          SELECT @EnhanceFlag =             CASE WHEN @ProductVersionMajor = 11 AND @ProductVersionMinor >= 6020 THEN 1              WHEN @ProductVersionMajor = 12 AND @ProductVersionMinor >= 5000 THEN 1              WHEN @ProductVersionMajor = 13 AND @ProductVersionMinor >= 1601 THEN 1              WHEN @ProductVersionMajor > 13 THEN 1              ELSE 0             END              IF OBJECT_ID(''sys.dm_exec_session_wait_stats'') IS NOT NULL          BEGIN           SET @SessionWaits = 1          END            /* Think of the StringToExecute as starting with this, but we will set this up later depending on whether we are doing an insert or a select          */          SELECT @StringToExecute = N'' COALESCE(                 CONVERT(VARCHAR(20), (ABS(r.total_elapsed_time) / 1000) / 86400) + '''':'''' + CONVERT(VARCHAR(20), DATEADD(SECOND, (r.total_elapsed_time / 1000), 0), 114) ,                 CONVERT(VARCHAR(20), DATEDIFF(SECOND, s.last_request_start_time, GETDATE()) / 86400) + '''':''''                  + CONVERT(VARCHAR(20), DATEADD(SECOND,  DATEDIFF(SECOND, s.last_request_start_time, GETDATE()), 0), 114)                  ) AS [elapsed_time] ,                s.session_id ,                COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid), ''''N/A'''') AS database_name,                ISNULL(SUBSTRING(dest.text,                     ( query_stats.statement_start_offset / 2 ) + 1,                     ( ( CASE query_stats.statement_end_offset                        WHEN -1 THEN DATALENGTH(dest.text)                        ELSE query_stats.statement_end_offset                      END - query_stats.statement_start_offset )                       / 2 ) + 1), dest.text) AS query_text ,                derp.query_plan ,''                 + @QueryStatsXMLselect                +''                 qmg.query_cost ,                s.status ,                COALESCE(wt.wait_info, RTRIM(blocked.lastwaittype) + '''' ('''' + CONVERT(VARCHAR(10), blocked.waittime) + '''')'''' ) AS wait_info ,''                +                CASE @SessionWaits                  WHEN 1 THEN + N''SUBSTRING(wt2.session_wait_info, 0, LEN(wt2.session_wait_info) ) AS top_session_waits ,''                  ELSE N'' NULL AS top_session_waits ,''                END                +                                 N''CASE WHEN r.blocking_session_id <> 0 AND blocked.session_id IS NULL                     THEN r.blocking_session_id                    WHEN r.blocking_session_id <> 0 AND s.session_id <> blocked.blocking_session_id                     THEN blocked.blocking_session_id                    ELSE NULL                   END AS blocking_session_id,                COALESCE(r.open_transaction_count, blocked.open_tran) AS open_transaction_count ,                CASE WHEN EXISTS (  SELECT 1                      FROM sys.dm_tran_active_transactions AS tat                     JOIN sys.dm_tran_session_transactions AS tst                     ON tst.transaction_id = tat.transaction_id                     WHERE tat.name = ''''implicit_transaction''''                     AND s.session_id = tst.session_id                      )  THEN 1                   ELSE 0                 END AS is_implicit_transaction ,                s.nt_domain ,                s.host_name ,                s.login_name ,                s.nt_user_name ,                s.program_name                 ''              IF @ExpertMode = 1          BEGIN              SET @StringToExecute +=                      N'', ''''DBCC FREEPROCCACHE ('''' + CONVERT(NVARCHAR(128), r.plan_handle, 1) + '''');'''' AS fix_parameter_sniffing,                            s.client_interface_name ,              s.login_time ,              r.start_time ,                qmg.request_time ,                          COALESCE(r.cpu_time, s.cpu_time) AS request_cpu_time,              COALESCE(r.logical_reads, s.logical_reads) AS request_logical_reads,              COALESCE(r.writes, s.writes) AS request_writes,              COALESCE(r.reads, s.reads) AS request_physical_reads ,              s.cpu_time AS session_cpu,              s.logical_reads AS session_logical_reads,              s.reads AS session_physical_reads ,              s.writes AS session_writes,                tempdb_allocations.tempdb_allocations_mb,              s.memory_usage ,              r.estimated_completion_time ,                 r.percent_complete ,               r.deadlock_priority ,                CASE                WHEN s.transaction_isolation_level = 0 THEN ''''Unspecified''''               WHEN s.transaction_isolation_level = 1 THEN ''''Read Uncommitted''''               WHEN s.transaction_isolation_level = 2 AND EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''''Read Committed Snapshot Isolation''''                 WHEN s.transaction_isolation_level = 2 AND NOT EXISTS (SELECT 1 FROM sys.dm_tran_active_snapshot_database_transactions AS trn WHERE s.session_id = trn.session_id AND is_snapshot = 0 ) THEN ''''Read Committed''''               WHEN s.transaction_isolation_level = 3 THEN ''''Repeatable Read''''               WHEN s.transaction_isolation_level = 4 THEN ''''Serializable''''               WHEN s.transaction_isolation_level = 5 THEN ''''Snapshot''''               ELSE ''''WHAT HAVE YOU DONE?''''              END AS transaction_isolation_level ,                qmg.dop AS degree_of_parallelism ,      ''                +                 CASE @EnhanceFlag                  WHEN 1 THEN N''query_stats.last_dop,              query_stats.min_dop,              query_stats.max_dop,              query_stats.last_grant_kb,              query_stats.min_grant_kb,              query_stats.max_grant_kb,              query_stats.last_used_grant_kb,              query_stats.min_used_grant_kb,              query_stats.max_used_grant_kb,              query_stats.last_ideal_grant_kb,              query_stats.min_ideal_grant_kb,              query_stats.max_ideal_grant_kb,              query_stats.last_reserved_threads,              query_stats.min_reserved_threads,              query_stats.max_reserved_threads,              query_stats.last_used_threads,              query_stats.min_used_threads,              query_stats.max_used_threads,''                  ELSE N'' NULL AS last_dop,              NULL AS min_dop,              NULL AS max_dop,              NULL AS last_grant_kb,              NULL AS min_grant_kb,              NULL AS max_grant_kb,              NULL AS last_used_grant_kb,              NULL AS min_used_grant_kb,              NULL AS max_used_grant_kb,              NULL AS last_ideal_grant_kb,              NULL AS min_ideal_grant_kb,              NULL AS max_ideal_grant_kb,              NULL AS last_reserved_threads,              NULL AS min_reserved_threads,              NULL AS max_reserved_threads,              NULL AS last_used_threads,              NULL AS min_used_threads,              NULL AS max_used_threads,''                END                 SET @StringToExecute +=                       N''              COALESCE(CAST(qmg.grant_time AS VARCHAR(20)), ''''Memory Not Granted'''') AS grant_time ,              qmg.requested_memory_kb ,              qmg.granted_memory_kb AS grant_memory_kb,              CASE WHEN qmg.grant_time IS NULL THEN ''''N/A''''              WHEN qmg.requested_memory_kb < qmg.granted_memory_kb               THEN ''''Query Granted Less Than Query Requested''''               ELSE ''''Memory Request Granted''''              END AS is_request_granted ,              qmg.required_memory_kb ,              qmg.used_memory_kb AS query_memory_grant_used_memory_kb,              qmg.ideal_memory_kb ,              qmg.is_small ,              qmg.timeout_sec ,              qmg.resource_semaphore_id ,              COALESCE(CAST(qmg.wait_order AS VARCHAR(20)), ''''N/A'''') AS wait_order ,              COALESCE(CAST(qmg.wait_time_ms AS VARCHAR(20)),               ''''N/A'''') AS wait_time_ms ,              CASE qmg.is_next_candidate               WHEN 0 THEN ''''No''''               WHEN 1 THEN ''''Yes''''               ELSE ''''N/A''''              END AS next_candidate_for_memory_grant ,              qrs.target_memory_kb ,              COALESCE(CAST(qrs.max_target_memory_kb AS VARCHAR(20)),               ''''Small Query Resource Semaphore'''') AS max_target_memory_kb ,              qrs.total_memory_kb ,              qrs.available_memory_kb ,              qrs.granted_memory_kb ,              qrs.used_memory_kb AS query_resource_semaphore_used_memory_kb,              qrs.grantee_count ,              qrs.waiter_count ,              qrs.timeout_error_count ,              COALESCE(CAST(qrs.forced_grant_count AS VARCHAR(20)),              ''''Small Query Resource Semaphore'''') AS forced_grant_count,              wg.name AS workload_group_name,               rp.name AS resource_pool_name,              CONVERT(VARCHAR(128), r.context_info)  AS context_info,              r.query_hash, r.query_plan_hash, r.sql_handle, r.plan_handle, r.statement_start_offset, r.statement_end_offset ''          END                 SET @StringToExecute +=             N'' FROM sys.dm_exec_sessions AS s           LEFT JOIN sys.dm_exec_requests AS r               ON   r.session_id = s.session_id           LEFT JOIN ( SELECT DISTINCT                wait.session_id ,                ( SELECT waitwait.wait_type + N'''' (''''                 + CAST(MAX(waitwait.wait_duration_ms) AS NVARCHAR(128))                 + N'''' ms) ''''                FROM   sys.dm_os_waiting_tasks AS waitwait                WHERE  waitwait.session_id = wait.session_id                GROUP BY  waitwait.wait_type                ORDER BY  SUM(waitwait.wait_duration_ms) DESC                FOR                XML PATH('''''''') ) AS wait_info               FROM sys.dm_os_waiting_tasks AS wait ) AS wt               ON   s.session_id = wt.session_id           LEFT JOIN sys.dm_exec_query_stats AS query_stats           ON   r.sql_handle = query_stats.sql_handle             AND r.plan_handle = query_stats.plan_handle            AND r.statement_start_offset = query_stats.statement_start_offset            AND r.statement_end_offset = query_stats.statement_end_offset           ''           +           CASE @SessionWaits             WHEN 1 THEN @SessionWaitsSQL             ELSE N''''           END           +            N''           LEFT JOIN sys.dm_exec_query_memory_grants qmg           ON   r.session_id = qmg.session_id             AND r.request_id = qmg.request_id           LEFT JOIN sys.dm_exec_query_resource_semaphores qrs           ON   qmg.resource_semaphore_id = qrs.resource_semaphore_id             AND qmg.pool_id = qrs.pool_id           LEFT JOIN sys.resource_governor_workload_groups wg            ON   s.group_id = wg.group_id           LEFT JOIN sys.resource_governor_resource_pools rp            ON  wg.pool_id = rp.pool_id           OUTER APPLY (             SELECT TOP 1             b.dbid, b.last_batch, b.open_tran, b.sql_handle,              b.session_id, b.blocking_session_id, b.lastwaittype, b.waittime             FROM @blocked b             WHERE (s.session_id = b.session_id               OR s.session_id = b.blocking_session_id)            ) AS blocked           OUTER APPLY sys.dm_exec_sql_text(COALESCE(r.sql_handle, blocked.sql_handle)) AS dest           OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS derp           OUTER APPLY (             SELECT CONVERT(DECIMAL(38,2), SUM( (((tsu.user_objects_alloc_page_count - user_objects_dealloc_page_count) * 8) / 1024.)) ) AS tempdb_allocations_mb             FROM sys.dm_db_task_space_usage tsu             WHERE tsu.request_id = r.request_id             AND tsu.session_id = r.session_id             AND tsu.session_id = s.session_id           ) as tempdb_allocations           ''           + @QueryStatsXMLSQL           +            N''           WHERE s.session_id <> @@SPID            AND s.host_name IS NOT NULL           ''           + CASE WHEN @ShowSleepingSPIDs = 0 THEN             N'' AND COALESCE(DB_NAME(r.database_id), DB_NAME(blocked.dbid)) IS NOT NULL''             WHEN @ShowSleepingSPIDs = 1 THEN             N'' OR COALESCE(r.open_transaction_count, blocked.open_tran) >= 1''             ELSE N'''' END;          END /* IF @ProductVersionMajor >= 11  */        IF (@MinElapsedSeconds + @MinCPUTime + @MinLogicalReads + @MinPhysicalReads + @MinWrites + @MinTempdbMB + @MinRequestedMemoryKB + @MinBlockingSeconds) > 0       BEGIN       /* They''re filtering for something, so set up a where clause that will let any (not all combined) of the min triggers work: */       SET @StringToExecute += N'' AND (1 = 0 '';       IF @MinElapsedSeconds > 0        SET @StringToExecute += N'' OR ABS(COALESCE(r.total_elapsed_time,0)) / 1000 >= '' + CAST(@MinElapsedSeconds AS NVARCHAR(20));       IF @MinCPUTime > 0        SET @StringToExecute += N'' OR COALESCE(r.cpu_time, s.cpu_time,0) / 1000 >= '' + CAST(@MinCPUTime AS NVARCHAR(20));       IF @MinLogicalReads > 0        SET @StringToExecute += N'' OR COALESCE(r.logical_reads, s.logical_reads,0) >= '' + CAST(@MinLogicalReads AS NVARCHAR(20));       IF @MinPhysicalReads > 0        SET @StringToExecute += N'' OR COALESCE(s.reads,0) >= '' + CAST(@MinPhysicalReads AS NVARCHAR(20));       IF @MinWrites > 0        SET @StringToExecute += N'' OR COALESCE(r.writes, s.writes,0) >= '' + CAST(@MinWrites AS NVARCHAR(20));       IF @MinTempdbMB > 0        SET @StringToExecute += N'' OR COALESCE(tempdb_allocations.tempdb_allocations_mb,0) >= '' + CAST(@MinTempdbMB AS NVARCHAR(20));       IF @MinRequestedMemoryKB > 0        SET @StringToExecute += N'' OR COALESCE(qmg.requested_memory_kb,0) >= '' + CAST(@MinRequestedMemoryKB AS NVARCHAR(20));       IF @MinBlockingSeconds > 0        SET @StringToExecute += N'' OR (SELECT SUM(waittime / 1000) FROM @blocked) >= '' + CAST(@MinBlockingSeconds AS NVARCHAR(20));       SET @StringToExecute += N'' ) '';       END        SET @StringToExecute +=         N'' ORDER BY 2 DESC;       '';          SET @StringToExecute = @BlockingCheck + N'' SELECT  GETDATE() AS run_date , '' + @StringToExecute;        EXEC(@StringToExecute);    END   '); EXEC ('    EXEC ##USP_BLITZWHO @Debug = 0, @ExpertMode = 1  '); EXEC ('  ');